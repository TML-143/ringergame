<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="theme-color" content="#050814" />
    <title>Ringer Game</title>

    <link rel="icon" href="ringer_game_icon.png" />
    <link rel="manifest" href="manifest.webmanifest" />

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7TEG531231"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){ dataLayer.push(arguments); }
      gtag('js', new Date());
    </script>

    <style>
html{background:var(--bg);}
:root{
  --bg:#050814;
  --panel:rgba(255,255,255,0.04);
  --panel2:rgba(255,255,255,0.06);
  --stroke:rgba(255,255,255,0.10);
  --stroke2:rgba(255,255,255,0.14);
  --text:#e8eeff;
  --muted:#9aa2bb;
  --accent:#f9c74f;
  --ok:#06d6a0;
  --bad:#ef476f;
}

*{box-sizing:border-box}
html,body{min-height:100%}
body{
  margin:0;
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  background:radial-gradient(1100px 500px at 20% -10%, rgba(249,199,79,0.12), transparent 60%),
             radial-gradient(900px 500px at 110% 0%, rgba(6,214,160,0.09), transparent 55%),
             var(--bg);
  color:var(--text);
}

#app{max-width:1220px;margin:0 auto;padding:14px}

.top-bar{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:16px;
  flex-wrap:wrap;
  padding:12px 14px;
  background:var(--panel);
  border:1px solid var(--stroke);
  border-radius:18px;
  box-shadow:0 12px 26px rgba(0,0,0,0.30);
}

h1{
  margin:0;
  font-size:20px;
  letter-spacing:0.2px;
}


#controls{
  display:flex;
  flex-wrap:wrap;
  gap:10px 14px;
  align-items:flex-end;
  justify-content:flex-end;
}

.control{display:flex;flex-direction:column;gap:6px;min-width:120px}
.control > label{font-size:12px;color:rgba(232,238,255,0.75)}
.control input, .control select{
  appearance:none;
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,255,255,0.12);
  border-radius:12px;
  padding:8px 10px;
  color:var(--text);
  outline:none;
}


/* Darker native dropdown menus (Chrome/Windows) */
select { color-scheme: dark; }
select option { background-color: #0b1026; color: #e8eeff; }

.control input:focus,.control select:focus{border-color:rgba(249,199,79,0.40);box-shadow:0 0 0 3px rgba(249,199,79,0.14)}

.control-buttons{flex-direction:row;gap:10px;min-width:auto}
.control-buttons button{
  border:1px solid rgba(255,255,255,0.14);
  background:rgba(255,255,255,0.06);
  color:var(--text);
  padding:9px 14px;
  border-radius:14px;
  cursor:pointer;
  font-weight:600;
}
.control-buttons button:hover{border-color:rgba(249,199,79,0.40)}
.control-buttons button:disabled{opacity:0.5;cursor:not-allowed}

.toggles{display:flex;gap:10px;flex-wrap:wrap}
.toggle{
  display:flex;align-items:center;gap:6px;
  padding:6px 10px;border-radius:999px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.04);
  user-select:none;
}

.path-row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.pill{
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.05);
  color:var(--text);
  padding:7px 10px;
  border-radius:999px;
  cursor:pointer;
  font-weight:600;
}
.pill.active{border-color:rgba(249,199,79,0.45);box-shadow:0 0 0 3px rgba(249,199,79,0.12) inset}

.bell-picker{
  display:grid;
  grid-template-columns:repeat(8,1fr);
  gap:8px;
}
.bell-picker--small{grid-template-columns:repeat(8,1fr)}
.bell-picker button{
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.03);
  color:var(--text);
  padding:8px 0;
  border-radius:12px;
  cursor:pointer;
  font-weight:700;
}
.bell-picker button.selected{
  border-color:rgba(249,199,79,0.50);
  box-shadow:0 0 0 3px rgba(249,199,79,0.12) inset;
  background:rgba(249,199,79,0.10);
}

.main{
  margin-top:12px;
  display:grid;
  grid-template-columns: 0.9fr 1.1fr;
  gap:12px;
  align-items:start;
}

#leftStack{
  display:flex;
  flex-direction:column;
  gap:12px;
  min-height:0;
}

.main.onecol{grid-template-columns:1fr}

.pane{
  background:var(--panel);
  border:1px solid var(--stroke);
  border-radius:18px;
  overflow:hidden;
  box-shadow:0 10px 22px rgba(0,0,0,0.24);
}

.pane-title{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  font-weight:700;
  font-size:13px;
  color:rgba(232,238,255,0.90);
}


/* Pane inline settings toggles */
.pane-actions{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:8px;
  flex-wrap:wrap;
}
.pane-actions .toggle{ padding:4px 8px; font-size:12px; }
.toggles--mini{ gap:6px; }
.pane canvas{
  display:block;
  width:100%;
  height:260px;
}
#displayCanvas{height:240px}
#notationCanvas{height:540px}

.pane-span{grid-column:1 / -1}
.pane-span #stats{padding:12px 14px}

.hidden{display:none !important}

.footer{
  margin-top:12px;
  padding:10px 14px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.03);
  color:rgba(232,238,255,0.78);
  font-size:12px;
}

.summary{
  padding:10px 12px;
  border-radius:14px;
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,255,255,0.08);
  margin-bottom:10px;
  font-weight:700;
}

#stats table{
  width:100%;
  border-collapse:separate;
  border-spacing:0;
}
#stats th,#stats td{
  text-align:right;
  padding:9px 10px;
  font-variant-numeric:tabular-nums;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
#stats th{color:rgba(232,238,255,0.75);font-size:12px;font-weight:700}
#stats td:first-child,#stats th:first-child{text-align:left}

.stats-info{
  margin-top:10px;
  color:rgba(232,238,255,0.70);
  font-size:12px;
  line-height:1.4;
}

.hit-window-control{
  display:flex;align-items:center;gap:10px;font-weight:600;
}
.hit-window-control label{font-size:12px;color:rgba(232,238,255,0.72);font-weight:700}
.hit-window-control select{padding:6px 10px;border-radius:12px}

@media (max-width: 980px){
  .main{grid-template-columns:1fr}
  #notationCanvas{height:460px}
}
    

/* Menu hide toggle */
.top-bar{ position:relative; }
.menu-toggle{
  position:absolute;
  top:12px;
  right:18px;
  width:36px;
  height:36px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.06);
  color:#e8eeff;
  cursor:pointer;
  display:grid;
  place-items:center;
  font-size:18px;
  line-height:1;
}
.menu-toggle:hover{ background:rgba(255,255,255,0.10); }
.menu-toggle:active{ transform:translateY(1px); }

.menu-hidden #controls .control:not(.control-buttons){
  display:none !important;
}
.menu-hidden #controls{
  gap:10px;
}
.menu-hidden .menu-toggle{
  transform:rotate(180deg);
}

/* Countdown overlay (Rounds count-up) */
.count-overlay{
  position:fixed;
  left:50%;
  top:84px;
  transform:translateX(-50%);
  z-index:60;
  display:none;
  pointer-events:none;
}
.count-overlay .bubble{
  min-width:110px;
  padding:18px 20px 14px;
  border-radius:20px;
  border:1px solid rgba(255,255,255,0.14);
  background:rgba(5,8,20,0.78);
  box-shadow:0 20px 70px rgba(0,0,0,0.55);
  text-align:center;
}
.count-overlay .num{
  font:800 64px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  color:#f9c74f;
}
.count-overlay .lbl{
  margin-top:8px;
  font:600 12px/1.1 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
  color:rgba(232,238,255,0.82);
  letter-spacing:0.06em;
  text-transform:uppercase;
}


.menu-hidden #controls{ padding-top:46px; }

.count-overlay .num.ready{ font-size:40px; letter-spacing:0.02em; }

/* Keybindings */
.keybind-panel{display:flex;flex-direction:column;gap:6px;min-width:180px}
.keybind-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.keybind-bell{font-size:12px;color:rgba(232,238,255,0.75);font-weight:700;min-width:60px}
.keybind-key{
  font:700 12px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.05);
  min-width:92px;
  text-align:center
}
.keybind-actions{margin-top:6px;display:flex;gap:10px;flex-wrap:wrap}
.keybind-bind-btn{padding:6px 10px;font-size:12px}
.keybind-row.capture .keybind-key{
  border-color:rgba(249,199,79,0.55);
  box-shadow:0 0 0 3px rgba(249,199,79,0.12) inset;
  background:rgba(249,199,79,0.10);
  color:#10162c
}
.keybind-row.conflict .keybind-key{
  border-color:rgba(239,71,111,0.55);
  box-shadow:0 0 0 3px rgba(239,71,111,0.10) inset
}
.keybind-note{font-size:11px;color:rgba(232,238,255,0.70);margin-top:4px;line-height:1.3}


/* Mic */
.mic-status{
  font-size:11px;
  color:rgba(232,238,255,0.70);
  line-height:1.2;
}
.pill.mic-on{
  border-color:rgba(6,214,160,0.55);
  box-shadow:0 0 0 3px rgba(6,214,160,0.12) inset;
  background:rgba(6,214,160,0.10);
}
.mic-body{ padding:12px 14px 14px; }
.mic-meter{
  position:relative;
  height:14px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.04);
  overflow:hidden;
}
.mic-meter-fill{
  height:100%;
  width:0%;
  background:rgba(249,199,79,0.85);
}
.mic-readouts{
  margin-top:10px;
  display:flex;
  gap:14px;
  flex-wrap:wrap;
  align-items:baseline;
}
.mic-label{
  color:rgba(232,238,255,0.78);
  font-weight:700;
  font-size:12px;
  margin-right:6px;
}
.control input[type="range"]{ padding:0; height:34px; }
</style>
  </head>
  <body>
    <div id="app">
      <div id="countOverlay" class="count-overlay" aria-hidden="true"></div>
      <header class="top-bar">
        <h1>Ringer Game</h1>
        <button id="menuToggle" class="menu-toggle" type="button" aria-label="Toggle menu" title="Hide menu">▾</button>

        <div id="controls">
          <div class="control">
            <label for="methodSelect">Method</label>
            <select id="methodSelect">
              <option value="plainhunt">Plain Hunt</option>
              <option value="plainbob">Plain Bob (variation)</option>
              <option value="grandsire">Grandsire (variation)</option>
              <option value="custom">Custom (text file)</option>
            </select>
          </div>

          <div class="control">
            <label for="bellCount">Bells</label>
            <select id="bellCount">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6" selected>6</option>
              <option value="7">7</option>
              <option value="8">8</option>
            </select>
          </div>

          <div class="control">
            <label for="scaleSelect">Scale</label>
            <select id="scaleSelect"></select>
          </div>

          <div class="control">
            <label for="octaveSelect">Octave</label>
            <select id="octaveSelect"></select>
          </div>

          <div class="control">
            <label for="liveCount">Live bells</label>
            <select id="liveCount"></select>
          </div>

          <div class="control">
            <label>Pick bells</label>
            <div id="bellPicker" class="bell-picker" aria-label="Pick bells"></div>
          </div>

          <div class="control">
            <label>Keybindings</label>
            <div id="keybindPanel" class="keybind-panel" aria-label="Keybindings"></div>
            <div class="keybind-actions">
              <button id="keybindResetBtn" class="pill" type="button">Reset to defaults</button>
            </div>
            <div id="keybindNote" class="keybind-note"></div>
          </div>

          <div class="control">
            <label for="bpmInput">Tempo (BPM)</label>
            <input id="bpmInput" type="number" min="30" max="240" value="80" />
          </div>

          <div class="control mic-control">
            <label>Mic</label>
            <div class="path-row">
              <button id="micToggleBtn" class="pill" type="button" aria-pressed="false">Mic OFF</button>
              <button id="micCalibrateBtn" class="pill" type="button">Calibrate</button>
              <span id="micCalibrateStatus" class="mic-status"></span>
              <span id="micStatus" class="mic-status"></span>
            </div>
          </div>

          <div class="control">
            <label for="micCooldown">Mic cooldown (ms)</label>
            <input id="micCooldown" type="range" min="100" max="400" step="10" value="200" />
            <div id="micCooldownVal" class="mic-status"></div>
          </div>

          <div class="control view-control">
            <label>View</label>
            <div class="toggles" role="group" aria-label="View toggles">
              <label class="toggle"><input id="viewDisplay" type="checkbox" checked /> Display</label>
              <label class="toggle"><input id="viewSpotlight" type="checkbox" checked /> Spotlight</label>
              <label class="toggle"><input id="viewNotation" type="checkbox" checked /> Notation</label>
              <label class="toggle"><input id="viewStats" type="checkbox" checked /> Stats</label>
              <label class="toggle"><input id="viewMic" type="checkbox" /> Mic</label>
            </div>
          </div>

         
          <div class="control">
            <label>Display</label>
            <div class="toggles toggles--mini" role="group" aria-label="Display toggles">
              <label class="toggle"><input id="displayLiveOnly" type="checkbox" /> Display live bell(s) only</label>
            </div>
          </div>

          <div class="control">
            <label>Spotlight swaps</label>
            <div class="toggles toggles--mini" role="group" aria-label="Spotlight swaps toggles">
              <label class="toggle"><input id="spotlightSwapsView" type="checkbox" /> Swaps view</label>
              <span id="spotlightSwapRows" class="toggles toggles--mini hidden" role="group" aria-label="Spotlight swap rows">
                <label class="toggle"><input id="spotlightShowN" type="checkbox" /> N</label>
                <label class="toggle"><input id="spotlightShowN1" type="checkbox" /> N+1</label>
                <label class="toggle"><input id="spotlightShowN2" type="checkbox" /> N+2</label>
              </span>
            </div>
          </div>

          <div class="control">
            <label>Notation swaps</label>
            <div class="toggles toggles--mini" role="group" aria-label="Notation swaps toggles">
              <label class="toggle"><input id="notationSwapsOverlay" type="checkbox" /> Notation swaps overlay</label>
            </div>
          </div>

          <div class="control path-control">
            <label>Path</label>
            <div class="path-row">
              <button id="pathNoneBtn" class="pill active" type="button">None</button>
              <button id="pathAllBtn" class="pill" type="button">All</button>
              <div id="pathPicker" class="bell-picker bell-picker--small" aria-label="Path bells"></div>
            </div>
          </div>

          <div class="control">
            <label for="fileInput">Custom file</label>
            <input id="fileInput" type="file" accept=".txt" />
          </div>

          <div class="control control-buttons">
            <button id="startBtn">Start</button>
            <button id="stopBtn" disabled>Stop</button>
          </div>
        </div>
      </header>

      <main id="main" class="main">
        <div id="leftStack">
          <section id="displayPane" class="pane">
            <div class="pane-title"><span>Display</span></div>
            <canvas id="displayCanvas" aria-label="Display"></canvas>
          </section>

          <section id="spotlightPane" class="pane">
            <div class="pane-title"><span>Spotlight</span></div>
            <canvas id="spotlightCanvas" aria-label="Spotlight"></canvas>
          </section>

          <section id="micPane" class="pane hidden">
            <div class="pane-title"><span>Mic</span></div>
            <div class="mic-body">
              <div class="mic-meter" aria-label="Mic level meter"><div id="micMeterFill" class="mic-meter-fill"></div></div>
              <div class="mic-readouts">
                <div><span class="mic-label">Level</span><span id="micDbReadout">–∞ dB</span></div>
                <div id="micPaneStatus" class="mic-status"></div>
              </div>
            </div>
          </section>
        </div>

        <section id="notationPane" class="pane">
          <div class="pane-title"><span>Notation</span></div>
          <canvas id="notationCanvas" aria-label="Notation"></canvas>
        </section>

        <section id="statsPane" class="pane pane-span">
          <div class="pane-title">
            <span>Stats</span>
          </div>
          <div id="stats"></div>
        </section>
      </main>

      <footer class="footer">
        <p id="hint">Keys 1–8 ring bells by default. Use Keybindings to rebind live bells (and Space/Enter when you have a single live bell). Tap/click bells in the Display. Non-live bells are rung by bots. Only your selected live bells are scored.</p>
      </footer>
    </div>

    <script>
(function () {
  'use strict';

  const LOOKAHEAD_MS = 160;
  const COUNTDOWN_BEATS = 3;

  // Row-based scoring: each bell has one beat-wide window per row, split into three equal thirds.
  // Middle third = 10 points, outer thirds = 9 points, miss = 0.

  // === Analytics (GA4) ===
  const GA_ID = 'G-7TEG531231';
  const SITE_VERSION = 'v10_display_scales';

  function safeJsonParse(txt) { try { return JSON.parse(txt); } catch (_) { return null; } }
  function safeGetLS(key) { try { return localStorage.getItem(key); } catch (_) { return null; } }
  function safeSetLS(key, val) { try { localStorage.setItem(key, val); } catch (_) {} }

  function safeGetBoolLS(key, def) {
    const v = safeGetLS(key);
    if (v == null) return def;
    if (v === '1' || v === 'true' || v === 'on') return true;
    if (v === '0' || v === 'false' || v === 'off') return false;
    return def;
  }
  function safeSetBoolLS(key, val) { safeSetLS(key, val ? '1' : '0'); }


  function rid(prefix) {
    try {
      if (window.crypto && crypto.getRandomValues) {
        const b = new Uint8Array(16);
        crypto.getRandomValues(b);
        let s = '';
        for (let i = 0; i < b.length; i++) s += b[i].toString(16).padStart(2, '0');
        return prefix + s;
      }
    } catch (_) {}
    return prefix + Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  const analytics = (function () {
    const LS_VISITOR = 'rg_visitor_id_v1';
    const LS_TOTALS = 'rg_visitor_totals_v1';

    const sessionId = rid('s_');

    let visitorId = safeGetLS(LS_VISITOR);
    if (!visitorId) {
      visitorId = rid('v_');
      safeSetLS(LS_VISITOR, visitorId);
    }

    const defaults = {
      plays_total: 0,
      seconds_total: 0,
      targets_total: 0,
      hits_total: 0,
      misses_total: 0,
      score_total: 0,
      pr_combo_global: 0
    };

    function loadTotals() {
      const raw = safeGetLS(LS_TOTALS);
      const parsed = raw ? safeJsonParse(raw) : null;
      const t = Object.assign({}, defaults, parsed || {});
      for (const k of Object.keys(defaults)) t[k] = Number(t[k] || 0);
      return t;
    }

    let totals = loadTotals();

    function configure() {
      try {
        if (typeof window.gtag === 'function') {
          window.gtag('config', GA_ID, {
            user_id: visitorId,
            allow_google_signals: false,
            allow_ad_personalization_signals: false
          });
        }
      } catch (_) {}
    }

    function track(name, params) {
      try {
        if (typeof window.gtag === 'function') window.gtag('event', name, params || {});
      } catch (_) {}
    }

    function setUserProps(props) {
      try {
        if (typeof window.gtag === 'function') window.gtag('set', 'user_properties', props || {});
      } catch (_) {}
    }

    function saveTotals() { safeSetLS(LS_TOTALS, JSON.stringify(totals)); }
    function refreshTotals() { totals = loadTotals(); return totals; }

    return { visitorId, sessionId, totals, configure, track, setUserProps, saveTotals, refreshTotals };
  })();

  // === DOM ===
  const main = document.getElementById('main');
  const leftStack = document.getElementById('leftStack');

  const displayPane = document.getElementById('displayPane');
  const spotlightPane = document.getElementById('spotlightPane');
  const micPane = document.getElementById('micPane');
  const notationPane = document.getElementById('notationPane');
  const statsPane = document.getElementById('statsPane');

  const displayCanvas = document.getElementById('displayCanvas');
  const dctx = displayCanvas.getContext('2d');
  const spotlightCanvas = document.getElementById('spotlightCanvas');
  const sctx = spotlightCanvas.getContext('2d');
  const notationCanvas = document.getElementById('notationCanvas');
  const nctx = notationCanvas.getContext('2d');

  const methodSelect = document.getElementById('methodSelect');
  const bellCountSelect = document.getElementById('bellCount');
  const scaleSelect = document.getElementById('scaleSelect');
  const octaveSelect = document.getElementById('octaveSelect');

  const liveCountSelect = document.getElementById('liveCount');
  const bellPicker = document.getElementById('bellPicker');
  const keybindPanel = document.getElementById('keybindPanel');
  const keybindResetBtn = document.getElementById('keybindResetBtn');
  const keybindNote = document.getElementById('keybindNote');
  const bpmInput = document.getElementById('bpmInput');

  // Mic controls (top menu)
  const micToggleBtn = document.getElementById('micToggleBtn');
  const micCalibrateBtn = document.getElementById('micCalibrateBtn');
  const micCalibrateStatus = document.getElementById('micCalibrateStatus');
  const micStatus = document.getElementById('micStatus');
  const micCooldown = document.getElementById('micCooldown');
  const micCooldownVal = document.getElementById('micCooldownVal');


// Mic pane
  const micMeterFill = document.getElementById('micMeterFill');
  const micDbReadout = document.getElementById('micDbReadout');
  const micPaneStatus = document.getElementById('micPaneStatus');

  const fileInput = document.getElementById('fileInput');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const menuToggle = document.getElementById('menuToggle');
  if (menuToggle) {
    menuToggle.addEventListener('click', () => {
      document.body.classList.toggle('menu-hidden');
    });
  }
  const statsDiv = document.getElementById('stats');

  const viewDisplay = document.getElementById('viewDisplay');
  const viewSpotlight = document.getElementById('viewSpotlight');
  const viewNotation = document.getElementById('viewNotation');
  const viewStats = document.getElementById('viewStats');
  const viewMic = document.getElementById('viewMic');
  const displayLiveOnly = document.getElementById('displayLiveOnly');


  // swaps view controls
  const spotlightSwapsView = document.getElementById('spotlightSwapsView');
  const spotlightSwapRows = document.getElementById('spotlightSwapRows');
  const spotlightShowN = document.getElementById('spotlightShowN');
  const spotlightShowN1 = document.getElementById('spotlightShowN1');
  const spotlightShowN2 = document.getElementById('spotlightShowN2');
  const notationSwapsOverlay = document.getElementById('notationSwapsOverlay');


  const pathNoneBtn = document.getElementById('pathNoneBtn');
  const pathAllBtn = document.getElementById('pathAllBtn');
  const pathPicker = document.getElementById('pathPicker');

  // swaps view localStorage keys
  const LS_SPOTLIGHT_SWAPS_VIEW = 'spotlight_swaps_view';
  const LS_SPOTLIGHT_SHOW_N = 'spotlight_show_N';
  const LS_SPOTLIGHT_SHOW_N1 = 'spotlight_show_N1';
  const LS_SPOTLIGHT_SHOW_N2 = 'spotlight_show_N2';
  const LS_NOTATION_SWAPS_OVERLAY = 'notation_swaps_overlay';
  const LS_DISPLAY_LIVE_BELLS_ONLY = 'display_live_bells_only';

  // mic localStorage keys
  const LS_MIC_ENABLED = 'rg_mic_enabled';
  const LS_MIC_BELLS = 'rg_mic_bells_v1';
  const LS_MIC_THRESHOLD = 'rg.mic.threshold';
  const OLD_LS_MIC_THRESHOLD_DB = 'rg_mic_threshold_db'; // v1 (dB slider)
  const LS_MIC_COOLDOWN_MS = 'rg_mic_cooldown_ms';


  function syncSpotlightSwapRowTogglesUI() {
    if (!spotlightSwapRows || !spotlightSwapsView) return;
    spotlightSwapRows.classList.toggle('hidden', !spotlightSwapsView.checked);
  }


  // === Musical scales (8 tones incl octave) ===
  // Intervals are semitones ascending from root to octave.
  const SCALE_LIBRARY = [
    { key: 'C_major', label: 'C major', root: 'C', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'Cs_major', label: 'C# major', root: 'C#', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'D_major', label: 'D major', root: 'D', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'Ef_major', label: 'Eb major', root: 'Eb', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'E_major', label: 'E major', root: 'E', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'F_major', label: 'F major', root: 'F', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'Fs_major', label: 'F# major', root: 'F#', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'G_major', label: 'G major', root: 'G', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'Af_major', label: 'Ab major', root: 'Ab', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'A_major', label: 'A major', root: 'A', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'Bf_major', label: 'Bb major', root: 'Bb', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'B_major', label: 'B major', root: 'B', intervals: [0,2,4,5,7,9,11,12] },
    { key: 'C_minor', label: 'C minor', root: 'C', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'Cs_minor', label: 'C# minor', root: 'C#', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'D_minor', label: 'D minor', root: 'D', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'Ef_minor', label: 'Eb minor', root: 'Eb', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'E_minor', label: 'E minor', root: 'E', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'F_minor', label: 'F minor', root: 'F', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'Fs_minor', label: 'F# minor', root: 'F#', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'G_minor', label: 'G minor', root: 'G', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'Af_minor', label: 'Ab minor', root: 'Ab', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'A_minor', label: 'A minor', root: 'A', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'Bf_minor', label: 'Bb minor', root: 'Bb', intervals: [0,2,3,5,7,8,10,12] },
    { key: 'B_minor', label: 'B minor', root: 'B', intervals: [0,2,3,5,7,8,10,12] }
  ];

  const NOTE_TO_SEMI = { 'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11 };

  function noteToMidi(note, octave) {
    const semi = NOTE_TO_SEMI[note];
    // MIDI: C-1 = 0, C4 = 60
    return (octave + 1) * 12 + semi;
  }
  function midiToFreq(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
  }

  // === Game state ===
  const state = {
    method: 'plainhunt',
    stage: 6,
    liveCount: 2,
    liveBells: [1, 2],
    bpm: 80,

    // musical settings
    scaleKey: 'C_major',
    octaveC: 3, // UI shows C1..C6
    bellFreq: [],

    pathBells: [],
    rows: [],
    customRows: null,
    phase: 'idle',

    countFirstBeatMs: 0,
    countExec: 0,
    countSched: 0,
    methodStartMs: 0,

    schedBeatIndex: 0,
    execBeatIndex: 0,

    targets: [],

    elapsedMs: 0,
    runStartPerfMs: 0,

    statsByBell: {},
    comboCurrentGlobal: 0,
    comboBestGlobal: 0,

    currentPlay: null, // { playId, began }

    lastRingAtMs: {}, // bell -> ms (intended beat time or actual key time)

    // keybindings
    keyBindings: {}, // bell -> normalized key name
    keybindCaptureBell: null,

    // swaps view settings
    spotlightSwapsView: true,
    spotlightShowN: true,
    spotlightShowN1: true,
    spotlightShowN2: true,
    notationSwapsOverlay: false,
    displayLiveBellsOnly: false,

    // mic input
    micEnabled: false,          // desired toggle state (persisted)
    micActive: false,           // stream + analyser running
    micStream: null,
    micSource: null,
    micAnalyser: null,
    micSink: null,
    micBuf: null,
    micRms: 0,
    micDb: -Infinity,
    micWasAbove: false,
    micLastFireTimeMs: -1e9,
    micCooldownMs: 200,
    micBells: [],
    micError: '',
  };

  let audioCtx = null;

  // Mic v2 threshold (linear RMS)
  const DEFAULT_MIC_THRESHOLD = 0.06;
  if (!Number.isFinite(window.micThreshold)) window.micThreshold = DEFAULT_MIC_THRESHOLD;

  function clamp(v, min, max) { return v < min ? min : (v > max ? max : v); }
  function perfNow() { return performance.now(); }

  // === Audio ===
  function ensureAudio() {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
    }
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }
  function closeAudio() {
    if (audioCtx) {
      // Keep the shared AudioContext alive while mic capture is active.
      if (state.micActive) return;
      try { audioCtx.close(); } catch (_) {}
      audioCtx = null;
    }
  }
  function msToAudioTime(whenMs) {
    ensureAudio();
    const deltaMs = Math.max(0, whenMs - perfNow());
    return audioCtx.currentTime + deltaMs / 1000;
  }

  function getBellFrequency(bell) {
    const i = bell - 1;
    return state.bellFreq[i] || 440;
  }

  function playBellAt(bell, whenMs) {
    ensureAudio();
    const t = msToAudioTime(whenMs);
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(getBellFrequency(bell), t);

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.16, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.28);

    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 0.32);
  }

  function playTickAt(whenMs) {
    ensureAudio();
    const t = msToAudioTime(whenMs);
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(1400, t);
    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.08, t + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 0.07);
  }

  // === Canvas helpers ===
  function fitCanvas(el, ctx) {
    const rect = el.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(2, Math.floor(rect.width * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if (el.width !== w || el.height !== h) { el.width = w; el.height = h; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { W: rect.width, H: rect.height };
  }
  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  // === Methods ===
  function applyX(row, stage) {
    const next = row.slice();
    for (let i = 0; i < stage - 1; i += 2) { const tmp = next[i]; next[i] = next[i+1]; next[i+1] = tmp; }
    return next;
  }
  function applyY(row, stage) {
    const next = row.slice();
    for (let i = 1; i < stage - 1; i += 2) { const tmp = next[i]; next[i] = next[i+1]; next[i+1] = tmp; }
    return next;
  }
  function makePlainHunt(stage, leads) {
    const rows = [];
    let current = [];
    for (let i = 1; i <= stage; i++) current.push(i);
    rows.push(current.slice());
    let useX = true;
    const steps = stage * 2 * leads;
    for (let i = 0; i < steps; i++) {
      current = useX ? applyX(current, stage) : applyY(current, stage);
      rows.push(current.slice());
      useX = !useX;
    }
    return rows;
  }
  function rotateRow(row, k) {
    const n = row.length;
    const off = ((k % n) + n) % n;
    return row.slice(off).concat(row.slice(0, off));
  }
  function makeLibraryRows(name, stage) {
    const base = makePlainHunt(stage, 5);
    if (name === 'plainbob') return base.map((r, i) => rotateRow(r, i % stage));
    if (name === 'grandsire') return base.map((r, i) => rotateRow(r, (i * 2) % stage));
    return base;
  }
  function parseCustom(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const rows = [];
    let stage = null;
    for (const line of lines) {
      if (!/^[1-9]+$/.test(line)) continue;
      const nums = line.split('').map(c => parseInt(c, 10));
      if (stage == null) stage = nums.length;
      if (nums.length !== stage) throw new Error('All rows must have the same number of bells.');
      rows.push(nums);
    }
    if (!rows.length) throw new Error('No valid rows found in file.');
    if (stage < 2 || stage > 12) throw new Error('Unsupported bell count in file.');
    return { rows, stage };
  }
  function computeRows() {
    if (state.method === 'custom' && state.customRows) state.rows = state.customRows.slice();
    else state.rows = makeLibraryRows(state.method, state.stage);
  }

  function methodLabel() {
    if (state.method === 'custom') return 'Custom';
    if (state.method === 'plainhunt') return 'Plain Hunt';
    if (state.method === 'plainbob') return 'Plain Bob (variation)';
    if (state.method === 'grandsire') return 'Grandsire (variation)';
    return state.method;
  }

  // === Scale -> bell frequencies ===
  function getScaleDef() { return SCALE_LIBRARY.find(s => s.key === state.scaleKey) || SCALE_LIBRARY[0]; }

  function downsampleIntervals(intervals, stage) {
    if (stage <= 1) return [intervals[0]];
    const out = [];
    const last = intervals.length - 1;
    for (let i = 0; i < stage; i++) {
      const t = i / (stage - 1);
      const idx = Math.round(t * last);
      out.push(intervals[idx]);
    }
    out[0] = intervals[0];
    out[out.length - 1] = intervals[last];
    return out;
  }

  function rebuildBellFrequencies() {
    const def = getScaleDef();
    const rootMidi = noteToMidi(def.root, state.octaveC);
    const rootFreq = midiToFreq(rootMidi);
    const intervals = downsampleIntervals(def.intervals, state.stage); // ascending low->high
    const freq = [];
    for (let bell = 1; bell <= state.stage; bell++) {
      const off = intervals[state.stage - bell]; // bell 1 highest
      freq.push(rootFreq * Math.pow(2, off / 12));
    }
    state.bellFreq = freq;
  }

  function currentTrebleToneLabel() { return getScaleDef().label; }
  function currentOctaveLabel() { return 'C' + String(state.octaveC); }

  // === Selection ===
  function ensureLiveBells() {
    const max = state.liveCount;
    const chosen = [];
    for (const b of state.liveBells) {
      if (b >= 1 && b <= state.stage && !chosen.includes(b)) {
        chosen.push(b);
        if (chosen.length >= max) break;
      }
    }
    if (!chosen.length) for (let b = 1; b <= state.stage && chosen.length < max; b++) chosen.push(b);
    state.liveBells = chosen;
  }

  function rebuildLiveCountOptions() {
    liveCountSelect.innerHTML = '';
    for (let n = 1; n <= state.stage; n++) {
      const opt = document.createElement('option');
      opt.value = String(n);
      opt.textContent = String(n);
      liveCountSelect.appendChild(opt);
    }
    state.liveCount = clamp(state.liveCount, 1, state.stage);
    liveCountSelect.value = String(state.liveCount);
  }

  function rebuildBellPicker() {
    ensureLiveBells();
    bellPicker.innerHTML = '';
    for (let b = 1; b <= state.stage; b++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = String(b);
      btn.addEventListener('click', () => {
        if (state.phase !== 'idle') return;
        const max = state.liveCount;
        const list = state.liveBells.slice();
        const idx = list.indexOf(b);
        if (idx >= 0) list.splice(idx, 1);
        else {
          if (list.length >= max) {
            if (max === 1) list.splice(0, 1, b);
            else return;
          } else list.push(b);
        }
        state.liveBells = list;
        rebuildBellPicker();
        resetStats();
      });
      if (state.liveBells.includes(b)) btn.classList.add('selected');
      bellPicker.appendChild(btn);
    }
    rebuildKeybindPanel();
    rebuildMicBellControls();
    syncMicToggleUI();
  }


  // === Keybindings ===
  const LS_KEYBINDS = 'rg_keybindings_v1';

  function normalizeBindKey(k) {
    if (k === ' ') return 'Space';
    if (k === 'Spacebar') return 'Space';
    if (!k) return '';
    if (k.length === 1) return k.toUpperCase();
    return k;
  }

  function formatBindKey(k) {
    const kk = normalizeBindKey(k);
    return kk ? kk : 'Unbound';
  }

  function isAllowedBindKey(k) {
    const kk = normalizeBindKey(k);
    return (kk.length === 1) || kk === 'Enter' || kk === 'Space';
  }

  function defaultBindKeyForBell(bell) {
    if (bell >= 1 && bell <= 8) return String(bell);
    return '';
  }

  function loadKeyBindings() {
    state.keyBindings = {};
    const raw = safeGetLS(LS_KEYBINDS);
    const parsed = raw ? safeJsonParse(raw) : null;
    if (parsed && typeof parsed === 'object') {
      for (const k in parsed) {
        if (!Object.prototype.hasOwnProperty.call(parsed, k)) continue;
        const bell = parseInt(k, 10);
        if (!isFinite(bell)) continue;
        const val = parsed[k];
        if (typeof val === 'string') state.keyBindings[bell] = normalizeBindKey(val);
      }
    }
  }

  function saveKeyBindings() {
    safeSetLS(LS_KEYBINDS, JSON.stringify(state.keyBindings));
  }

  function ensureKeyBindings() {
    for (let b = 1; b <= state.stage; b++) {
      if (!Object.prototype.hasOwnProperty.call(state.keyBindings, b)) {
        state.keyBindings[b] = defaultBindKeyForBell(b);
      }
    }
  }

  function resetKeyBindingsToDefaults() {
    for (let b = 1; b <= 8; b++) state.keyBindings[b] = String(b);
    saveKeyBindings();
  }

  function getLiveKeyConflicts() {
    const live = state.liveBells.slice();
    const usage = {};
    for (const b of live) {
      const k = state.keyBindings[b];
      if (!k) continue;
      if (!usage[k]) usage[k] = [];
      usage[k].push(b);
    }
    const conflicts = new Set();
    for (const k in usage) {
      if (usage[k].length > 1) usage[k].forEach(b => conflicts.add(b));
    }
    return conflicts;
  }

  function rebuildKeybindPanel() {
    if (!keybindPanel) return;
    ensureKeyBindings();

    const live = state.liveBells.slice().sort((a,b)=>a-b);
    keybindPanel.innerHTML = '';

    if (!live.length) {
      keybindPanel.textContent = 'No live bells selected.';
      if (keybindNote) keybindNote.textContent = '';
      return;
    }

    const conflicts = getLiveKeyConflicts();

    live.forEach(b => {
      const row = document.createElement('div');
      row.className = 'keybind-row';
      if (conflicts.has(b)) row.classList.add('conflict');
      if (state.keybindCaptureBell === b) row.classList.add('capture');

      const bellLabel = document.createElement('span');
      bellLabel.className = 'keybind-bell';
      bellLabel.textContent = 'Bell ' + b;

      const keyLabel = document.createElement('span');
      keyLabel.className = 'keybind-key';
      keyLabel.textContent = (state.keybindCaptureBell === b) ? 'Press key…' : formatBindKey(state.keyBindings[b]);

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'pill keybind-bind-btn';
      btn.textContent = (state.keybindCaptureBell === b) ? 'Cancel' : 'Bind key';
      btn.disabled = state.phase !== 'idle';
      btn.addEventListener('click', () => {
        if (state.phase !== 'idle') return;
        state.keybindCaptureBell = (state.keybindCaptureBell === b) ? null : b;
        rebuildKeybindPanel();
      });

      const micBtn = document.createElement('button');
      micBtn.type = 'button';
      micBtn.className = 'pill keybind-bind-btn keybind-mic-btn';
      micBtn.textContent = 'Mic';
      micBtn.setAttribute('data-mic-bell', String(b));
      micBtn.title = 'Toggle mic input for this bell';
      const micOn = (state.micBells || []).includes(b);
      micBtn.classList.toggle('mic-on', micOn);
      micBtn.setAttribute('aria-pressed', micOn ? 'true' : 'false');
      micBtn.setAttribute('aria-label', micOn ? `Mic on for bell ${b}` : `Mic off for bell ${b}`);
      micBtn.addEventListener('click', () => {
        const set = new Set(state.micBells || []);
        if (set.has(b)) set.delete(b);
        else set.add(b);
        state.micBells = Array.from(set).sort((x, y) => x - y);
        rebuildMicBellControls();
        syncMicToggleUI();
      });

      row.appendChild(bellLabel);
      row.appendChild(keyLabel);
      row.appendChild(btn);
      row.appendChild(micBtn);

      keybindPanel.appendChild(row);
    });

    if (keybindResetBtn) keybindResetBtn.disabled = state.phase !== 'idle';

    if (keybindNote) {
      if (state.keybindCaptureBell != null) {
        keybindNote.textContent = 'Press a letter/number key, Space, or Enter (Esc to cancel).';
      } else if (live.length === 1) {
        keybindNote.textContent = 'Tip: Space and Enter also ring the only live bell.';
      } else if (conflicts.size) {
        keybindNote.textContent = 'Fix conflicts: each key can be bound to only one live bell.';
      } else keybindNote.textContent = '';
    }
  }


  function ensurePathBells() {
    const keep = [];
    for (const b of state.pathBells) if (b >= 1 && b <= state.stage && !keep.includes(b)) keep.push(b);
    state.pathBells = keep;
  }
  function updatePathButtons() {
    const none = state.pathBells.length === 0;
    const all = state.pathBells.length === state.stage && state.pathBells.every(b => b>=1 && b<=state.stage);
    pathNoneBtn.classList.toggle('active', none);
    pathAllBtn.classList.toggle('active', all);
  }
  function rebuildPathPicker() {
    ensurePathBells();
    pathPicker.innerHTML = '';
    for (let b = 1; b <= state.stage; b++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = String(b);
      btn.addEventListener('click', () => {
        const list = state.pathBells.slice();
        const idx = list.indexOf(b);
        if (idx >= 0) list.splice(idx, 1);
        else list.push(b);
        state.pathBells = list;
        rebuildPathPicker();
      });
      if (state.pathBells.includes(b)) btn.classList.add('selected');
      pathPicker.appendChild(btn);
    }
    updatePathButtons();
  }
  function setPathNone() { state.pathBells = []; rebuildPathPicker(); }
  function setPathAll() { state.pathBells = []; for (let b=1; b<=state.stage; b++) state.pathBells.push(b); rebuildPathPicker(); }
  function getPathMode() {
    if (state.pathBells.length === 0) return 'none';
    if (state.pathBells.length === state.stage) return 'all';
    return 'custom';
  }

  // === View layout ===
  function syncViewLayout() {
    displayPane.classList.toggle('hidden', !viewDisplay.checked);
    spotlightPane.classList.toggle('hidden', !viewSpotlight.checked);
    micPane.classList.toggle('hidden', !viewMic.checked);
    notationPane.classList.toggle('hidden', !viewNotation.checked);
    statsPane.classList.toggle('hidden', !viewStats.checked);

    const leftVisible = viewDisplay.checked || viewSpotlight.checked || viewMic.checked;
    leftStack.classList.toggle('hidden', !leftVisible);

    const rightVisible = viewNotation.checked;
    main.classList.toggle('onecol', !(leftVisible && rightVisible));
  }


  // === Mic input (silent scoring) ===
  function dbToLin(db) { return Math.pow(10, db / 20); }
  function linToDb(lin) { return lin > 0 ? (20 * Math.log10(lin)) : -Infinity; }

  function setMicUiStatus(msg, isError = false) {
    if (micStatus) {
      micStatus.textContent = msg || '';
      micStatus.style.color = isError ? 'rgba(255, 107, 107, 0.95)' : '';
    }
    if (micPaneStatus) {
      micPaneStatus.textContent = msg || '';
      micPaneStatus.style.color = isError ? 'rgba(255, 107, 107, 0.95)' : '';
    }
  }

  function syncMicToggleUI() {
    if (!micToggleBtn) return;
    const on = !!state.micEnabled;
    micToggleBtn.textContent = on ? 'Mic ON' : 'Mic OFF';
    micToggleBtn.classList.toggle('mic-on', on);
    micToggleBtn.setAttribute('aria-pressed', on ? 'true' : 'false');

    // status hint
    if (!on) {
      setMicUiStatus(state.micError ? state.micError : '', !!state.micError);
      return;
    }

    const live = (state.liveBells || []).length;
    const chosen = getMicControlledBells().length;
    if (live >= 1 && chosen === 0) {
      setMicUiStatus('Select mic bell(s) below');
      return;
    }

    if (!state.micActive) {
      // Enabled in UI, but capture requires a gesture.
      setMicUiStatus(state.micError ? state.micError : 'Click Mic or Start to activate', !!state.micError);
      return;
    }

    // Active: only show errors persistently.
    setMicUiStatus(state.micError ? state.micError : '', !!state.micError);
  }

  function syncMicSlidersUI() {
    if (micCooldown) micCooldown.value = String(state.micCooldownMs);
    if (micCooldownVal) micCooldownVal.textContent = `${Math.round(state.micCooldownMs)} ms`;
  }

  let micCalibrateTimer = null;
  let micCalibrating = false;

  function setMicCalibrateStatus(msg, isError = false, autoClearMs = 2500) {
    if (!micCalibrateStatus) return;
    micCalibrateStatus.textContent = msg || '';
    micCalibrateStatus.style.color = isError ? 'rgba(255, 107, 107, 0.95)' : '';
    if (micCalibrateTimer) {
      clearTimeout(micCalibrateTimer);
      micCalibrateTimer = null;
    }
    if (msg && autoClearMs > 0) {
      micCalibrateTimer = setTimeout(() => {
        if (!micCalibrateStatus) return;
        micCalibrateStatus.textContent = '';
        micCalibrateStatus.style.color = '';
        micCalibrateTimer = null;
      }, autoClearMs);
    }
  }

  function rmsFromByteTimeDomain(bytes) {
    let sum = 0;
    for (let i = 0; i < bytes.length; i++) {
      const v = (bytes[i] - 128) / 128;
      sum += v * v;
    }
    return Math.sqrt(sum / bytes.length);
  }

  async function calibrateMicThreshold() {
    if (micCalibrating) return;
    micCalibrating = true;
    if (micCalibrateBtn) micCalibrateBtn.disabled = true;

    const durationMs = 1200;
    const headroom = 1.8;

    let tmpStream = null;
    let tmpSource = null;
    let tmpAnalyser = null;
    let tmpSink = null;
    let usingExisting = false;

    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('getUserMedia not supported');

      setMicCalibrateStatus('listening…', false, 0);

      let analyser = null;
      if (state.micActive && state.micAnalyser) {
        analyser = state.micAnalyser;
        usingExisting = true;
      } else {
        ensureAudio();
        try { if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume(); } catch (_) {}

        tmpStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
          }
        });
        tmpSource = audioCtx.createMediaStreamSource(tmpStream);
        tmpAnalyser = audioCtx.createAnalyser();
        tmpAnalyser.fftSize = 2048;
        tmpSink = audioCtx.createMediaStreamDestination();
        tmpSource.connect(tmpAnalyser);
        tmpAnalyser.connect(tmpSink);
        analyser = tmpAnalyser;
      }

      const buf = new Uint8Array(analyser.fftSize);
      const samples = [];
      const startMs = perfNow();

      await new Promise(resolve => {
        const tick = () => {
          analyser.getByteTimeDomainData(buf);
          samples.push(rmsFromByteTimeDomain(buf));
          if (perfNow() - startMs < durationMs) requestAnimationFrame(tick);
          else resolve();
        };
        tick();
      });

      if (!samples.length) throw new Error('no samples');
      samples.sort((a, b) => a - b);
      const mid = Math.floor(samples.length / 2);
      const median = (samples.length % 2) ? samples[mid] : (samples[mid - 1] + samples[mid]) / 2;

      const next = clamp(median * headroom, 0.01, 0.25);
      window.micThreshold = next;
      safeSetLS(LS_MIC_THRESHOLD, String(next));

      setMicCalibrateStatus(`threshold: ${next.toFixed(3)}`, false, 2500);
    } catch (err) {
      console.error('Mic calibration failed', err);
      const denied = err && (err.name === 'NotAllowedError' || err.name === 'SecurityError');
      setMicCalibrateStatus(denied ? 'mic denied' : 'calibration failed', true, 2500);
    } finally {
      // cleanup
      try {
        if (!usingExisting && tmpSource) tmpSource.disconnect();
      } catch (_) {}
      try {
        if (!usingExisting && tmpAnalyser) tmpAnalyser.disconnect();
      } catch (_) {}
      if (tmpStream) {
        try { tmpStream.getTracks().forEach(t => t.stop()); } catch (_) {}
      }

      if (micCalibrateBtn) micCalibrateBtn.disabled = false;
      micCalibrating = false;
    }
  }

  function parseBellList(s) {
    if (!s) return [];
    const out = [];
    String(s).split(',').forEach(x => {
      const n = parseInt(String(x).trim(), 10);
      if (!Number.isFinite(n)) return;
      if (n < 1 || n > 12) return;
      out.push(n);
    });
    return Array.from(new Set(out)).sort((a, b) => a - b);
  }


  function getMicControlledBells() {
    const live = (state.liveBells || []).slice().sort((a, b) => a - b);
    const liveSet = new Set(live);
    const chosen = (state.micBells || []).filter(b => liveSet.has(b));
    // dedupe + sort
    return Array.from(new Set(chosen)).sort((a, b) => a - b);
  }

  function rebuildMicBellControls() {
    // Mic v2: per-bell mic toggles live next to "Bind key" in the Keybindings panel.
    safeSetLS(LS_MIC_BELLS, (state.micBells || []).join(','));

    // Update any visible per-bell Mic buttons without forcing a full rebuild.
    try {
      const btns = document.querySelectorAll('[data-mic-bell]');
      btns.forEach(btn => {
        const bell = parseInt(btn.getAttribute('data-mic-bell') || '', 10);
        const on = Number.isFinite(bell) && (state.micBells || []).includes(bell);
        btn.classList.toggle('mic-on', on);
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        btn.setAttribute('aria-label', on ? `Mic on for bell ${bell}` : `Mic off for bell ${bell}`);
      });
    } catch (_) {}
  }


  function loadMicPrefs() {
    state.micEnabled = safeGetBoolLS(LS_MIC_ENABLED, false);

    // Mic threshold (linear RMS)
    let th = parseFloat(safeGetLS(LS_MIC_THRESHOLD) || '');
    if (!Number.isFinite(th)) {
      // Migrate legacy dB slider value if present.
      const oldDb = parseFloat(safeGetLS(OLD_LS_MIC_THRESHOLD_DB) || '');
      if (Number.isFinite(oldDb)) th = dbToLin(clamp(oldDb, -72, 0));
    }
    if (Number.isFinite(th)) window.micThreshold = clamp(th, 0.01, 0.25);
    else window.micThreshold = DEFAULT_MIC_THRESHOLD;

    // Persist to the new key so it sticks going forward.
    safeSetLS(LS_MIC_THRESHOLD, String(window.micThreshold));

    const cd = parseFloat(safeGetLS(LS_MIC_COOLDOWN_MS) || '');
    if (Number.isFinite(cd)) state.micCooldownMs = clamp(cd, 100, 400);

    const bellsRaw = safeGetLS(LS_MIC_BELLS);
    state.micBells = (bellsRaw == null) ? (state.liveBells || []).slice() : parseBellList(bellsRaw);
    if (bellsRaw == null) safeSetLS(LS_MIC_BELLS, state.micBells.join(','));

    syncMicSlidersUI();
    rebuildMicBellControls();
    syncMicToggleUI();
  }


  function setMicEnabled(on, opts = {}) {
    const next = !!on;
    if (next) state.micError = '';
    state.micEnabled = next;
    safeSetBoolLS(LS_MIC_ENABLED, next);

    if (!next) {
      if (!opts.keepError) state.micError = '';
      stopMicCapture();
    }
    syncMicToggleUI();
  }

  function stopMicCapture() {
    state.micActive = false;

    try { if (state.micSource) state.micSource.disconnect(); } catch (_) {}
    try { if (state.micAnalyser) state.micAnalyser.disconnect(); } catch (_) {}
    try { if (state.micSink) state.micSink.disconnect(); } catch (_) {}
    state.micSource = null;
    state.micAnalyser = null;
    state.micSink = null;
    state.micBuf = null;

    if (state.micStream) {
      try { state.micStream.getTracks().forEach(t => t.stop()); } catch (_) {}
    }
    state.micStream = null;

    state.micWasAbove = false;
    if (micMeterFill) micMeterFill.style.width = '0%';
    if (micDbReadout) micDbReadout.textContent = '–∞ dB';

    // If mic was the only reason we kept audio alive while idle, restore old behavior.
    if (state.phase === 'idle') closeAudio();
  }

  function startMicCapture() {
    if (!state.micEnabled || state.micActive) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      state.micError = 'Mic unsupported';
      setMicEnabled(false, { keepError: true });
      setMicUiStatus('Mic unsupported', true);
      return;
    }

    ensureAudio();
    setMicUiStatus('Requesting mic…');
    navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    }).then(stream => {
      if (!state.micEnabled) { stream.getTracks().forEach(t => t.stop()); return; }
      state.micStream = stream;
      state.micSource = audioCtx.createMediaStreamSource(stream);

      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.2;

      // Keep graph alive without speaker output.
      const sink = audioCtx.createMediaStreamDestination();
      state.micAnalyser = analyser;
      state.micSink = sink;

      state.micSource.connect(analyser);
      analyser.connect(sink);

      state.micBuf = new Float32Array(analyser.fftSize);
      state.micActive = true;
      state.micWasAbove = false;
      state.micLastFireTimeMs = -1e9;

      setMicUiStatus('');
      syncMicToggleUI();
    }).catch(err => {
      const name = err && err.name ? String(err.name) : '';
      state.micError = (name === 'NotAllowedError' || name === 'SecurityError') ? 'Mic blocked' : 'Mic error';
      setMicEnabled(false, { keepError: true });
      setMicUiStatus(state.micError, true);
    });
  }

  function updateMicMeter(rms) {
    const db = linToDb(rms);
    state.micRms = rms;
    state.micDb = db;

    if (micDbReadout) micDbReadout.textContent = Number.isFinite(db) ? `${Math.round(db)} dB` : '–∞ dB';
    if (micMeterFill) {
      const p = Number.isFinite(db) ? clamp((db + 72) / 72, 0, 1) : 0;
      micMeterFill.style.width = `${Math.round(p * 100)}%`;
    }
  }

  function pickMicTargetInWindow(nowMs) {
    if (state.phase !== 'running') return null;
    const bells = getMicControlledBells();
    if (!bells.length) return null;

    const bellSet = new Set(bells);
    const beatMs = 60000 / state.bpm;
    const halfBeat = beatMs / 2;

    let chosen = null;
    for (const t of state.targets) {
      if (t.judged) continue;
      if (!bellSet.has(t.bell)) continue;

      const ws = t.timeMs - halfBeat;
      const we = t.timeMs + halfBeat;
      if (nowMs >= ws && nowMs < we) {
        if (!chosen || t.timeMs < chosen.timeMs || (t.timeMs === chosen.timeMs && t.bell < chosen.bell)) chosen = t;
      }
    }
    return chosen;
  }

  function registerMicHit(bell, timeMs) {
    // Mic hits are silent: score + visuals only, no bell audio.
    markRung(bell, timeMs);
    scoreHit(bell, timeMs);
  }

  function updateMicAnalysis(nowMs) {
    if (!state.micActive || !state.micAnalyser || !state.micBuf) return;
    try { state.micAnalyser.getFloatTimeDomainData(state.micBuf); } catch (_) { return; }

    let sum = 0;
    const buf = state.micBuf;
    for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
    const rms = Math.sqrt(sum / buf.length);
    updateMicMeter(rms);

    const thresholdLin = clamp(Number(window.micThreshold) || DEFAULT_MIC_THRESHOLD, 0.01, 0.25);
    const above = rms >= thresholdLin;
    const rising = above && !state.micWasAbove;

    if (rising) {
      const cdOk = (nowMs - state.micLastFireTimeMs) >= state.micCooldownMs;
      if (cdOk) {
        const target = pickMicTargetInWindow(nowMs);
        if (target) {
          registerMicHit(target.bell, nowMs);
          state.micLastFireTimeMs = nowMs;
        }
      }
    }
    state.micWasAbove = above;
  }

  // === Visual ring flash ===
  function markRung(bell, atMs) { state.lastRingAtMs[bell] = atMs; }

  // === Bell ring action (user) ===
  function ringBell(bell) {
    const now = perfNow();
    markRung(bell, now);
    playBellAt(bell, now);
    if (state.phase === 'running') scoreHit(bell, now);
  }

  // === Stats ===
  function resetStats() {
    state.statsByBell = {};
    for (let b = 1; b <= state.stage; b++) {
      state.statsByBell[b] = { bell: b, hits: 0, misses: 0, sumAbsDelta: 0, sumSignedDelta: 0, score: 0, comboCurrent: 0, comboBest: 0 };
    }
    state.targets.length = 0;
    state.comboCurrentGlobal = 0;
    state.comboBestGlobal = 0;
  }

  function getBellForStrikeIndex(i) {
    const stage = state.stage;
    const rowIdx = Math.floor(i / stage);
    const pos = i % stage;
    const row = state.rows[rowIdx];
    return row ? row[pos] : 1;
  }

  function recordTarget(bell, timeMs) {
    state.targets.push({ bell, timeMs, judged: false, hit: false });
  }

  function buildAllTargets(beatMs) {
    state.targets.length = 0;
    const stage = state.stage;
    const totalBeats = state.rows.length * stage;
    for (let i = 0; i < totalBeats; i++) {
      const bell = getBellForStrikeIndex(i);
      const tMs = state.methodStartMs + i * beatMs;
      recordTarget(bell, tMs);
    }
  }

  function updateMisses(nowMs) {
    const live = new Set(state.liveBells);
    const beatMs = 60000 / state.bpm;
    const halfBeat = beatMs / 2;
    for (const t of state.targets) {
      if (t.judged) continue;
      if (nowMs > t.timeMs + halfBeat) {
        t.judged = true;
        if (live.has(t.bell)) {
          const s = state.statsByBell[t.bell];
          s.misses += 1;
          s.comboCurrent = 0;
          state.comboCurrentGlobal = 0;
        }
      }
    }
    const cutoff = nowMs - 8000;
    while (state.targets.length && state.targets[0].timeMs < cutoff && state.targets[0].judged) state.targets.shift();
  }

  function finalizePendingAsMisses(nowMs) {
    state.targets = state.targets.filter(t => t.timeMs <= nowMs);
    const live = new Set(state.liveBells);
    for (const t of state.targets) {
      if (t.judged) continue;
      t.judged = true;
      if (live.has(t.bell)) {
        const s = state.statsByBell[t.bell];
        s.misses += 1;
        s.comboCurrent = 0;
        state.comboCurrentGlobal = 0;
      }
    }
  }

  function scoreHit(bell, timeMs) {
    if (state.phase !== 'running') return;
    if (!state.liveBells.includes(bell)) return;

    const beatMs = 60000 / state.bpm;
    const halfBeat = beatMs / 2;

    // Only the first ring for this bell within the current row counts (hit or miss).
    const rel = timeMs - (state.methodStartMs - halfBeat);
    if (rel < 0) return;

    const beatIndex = Math.floor(rel / beatMs);
    if (beatIndex < 0) return;

    const rowIdx = Math.floor(beatIndex / state.stage);
    if (rowIdx < 0 || rowIdx >= state.rows.length) return;

    const row = state.rows[rowIdx];
    if (!row) return;

    const posInRow = row.indexOf(bell);
    if (posInRow < 0) return;

    const targetTimeMs = state.methodStartMs + (rowIdx * state.stage + posInRow) * beatMs;

    let t = null;
    let bestAbs = Infinity;
    for (let i = 0; i < state.targets.length; i++) {
      const cand = state.targets[i];
      if (cand.bell !== bell) continue;
      const abs = Math.abs(cand.timeMs - targetTimeMs);
      if (abs < bestAbs) { bestAbs = abs; t = cand; }
    }
    if (!t) return;
    if (bestAbs > halfBeat) return; // target already expired/trimmed
    if (t.judged) return;

    const windowStart = targetTimeMs - halfBeat;
    const windowEnd = targetTimeMs + halfBeat;

    // Miss if the first ring in the row is outside the bell's own window.
    if (timeMs < windowStart || timeMs >= windowEnd) {
      t.judged = true;
      t.hit = false;

      const s = state.statsByBell[bell];
      s.misses += 1;
      s.comboCurrent = 0;
      state.comboCurrentGlobal = 0;
      return;
    }

    // Hit: score within the bell window (middle third = 10, outer thirds = 9).
    t.judged = true;
    t.hit = true;

    const deltaMs = timeMs - targetTimeMs;
    const absDelta = Math.abs(deltaMs);
    const s = state.statsByBell[bell];

    s.hits += 1;
    s.sumAbsDelta += absDelta;
    s.sumSignedDelta += deltaMs;

    const offset = clamp(timeMs - windowStart, 0, beatMs);
    const third = beatMs / 3;
    let points = 9;
    if (offset >= third && offset < 2 * third) points = 10;

    s.score += points;

    s.comboCurrent += 1;
    if (s.comboCurrent > s.comboBest) s.comboBest = s.comboCurrent;

    state.comboCurrentGlobal += 1;
    if (state.comboCurrentGlobal > state.comboBestGlobal) state.comboBestGlobal = state.comboCurrentGlobal;
  }

  function getElapsedSeconds(nowMs) {
    if (state.phase === 'running') return (state.elapsedMs + (nowMs - state.runStartPerfMs)) / 1000;
    return state.elapsedMs / 1000;
  }

  function countdownDisplay(nowMs) {
    if (state.phase !== 'countdown') return null;
    const beatMs = 60000 / state.bpm;

    // Before the first count-in beat, show Ready (no sound yet).
    if (nowMs < state.countFirstBeatMs) return 'Ready';

    const k = Math.floor((nowMs - state.countFirstBeatMs) / beatMs); // 0-based count-in beat
    if (k >= 0 && k < state.stage) return String(k + 1);
    return null;
  }

  const countOverlay = document.getElementById('countOverlay');
  function renderCountdownOverlay(nowMs) {
    if (!countOverlay) return;
    const cd = countdownDisplay(nowMs);
    if (!cd) { countOverlay.style.display = 'none'; countOverlay.innerHTML = ''; return; }

    countOverlay.style.display = 'block';

    if (cd === 'Ready') {
      countOverlay.innerHTML =
        '<div class="bubble"><div class="num ready">Ready</div><div class="lbl">Count in</div></div>';
      return;
    }

    countOverlay.innerHTML =
      '<div class="bubble"><div class="num">' + cd + '</div><div class="lbl">Count in</div></div>';
  }


  // === Spotlight (cue only; not clickable) ===
    function drawSpotlight(nowMs) {
      const { W, H } = fitCanvas(spotlightCanvas, sctx);
      sctx.clearRect(0, 0, W, H);

      const cd = countdownDisplay(nowMs);
      if (!state.rows.length) return;

      // countdown badge intentionally omitted (overlay handles count-in)

      const stage = state.stage;
      const totalBeats = state.rows.length * stage;
      const strikeIdx = clamp(state.execBeatIndex - 1, 0, Math.max(0, totalBeats - 1));
      const rowIdx = Math.floor(strikeIdx / stage);
      const pos = strikeIdx % stage;

      // Default Spotlight (exactly as before)
      if (!state.spotlightSwapsView) {
        const currentRow = state.rows[rowIdx] || state.rows[0];
        const nextRow = state.rows[Math.min(rowIdx + 1, state.rows.length - 1)] || currentRow;

        const padX = 14, padY = 12, gapY = 10;
        const rowBlockH = (H - padY * 2 - gapY) / 2;
        const cellW = (W - padX * 2) / stage;

        function drawRow(row, yTop, highlightPos, faded) {
          sctx.save();
          sctx.translate(padX, yTop);
          sctx.fillStyle = faded ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.05)';
          sctx.strokeStyle = 'rgba(255,255,255,0.08)';
          roundRect(sctx, 0, 0, W - padX * 2, rowBlockH, 12);
          sctx.fill(); sctx.stroke();

          const fontSize = Math.max(20, Math.min(34, Math.floor(rowBlockH * 0.58)));
          sctx.font = fontSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
          sctx.textAlign = 'center';
          sctx.textBaseline = 'middle';

          for (let i = 0; i < stage; i++) {
            const x = i * cellW + cellW / 2;
            const y = rowBlockH / 2;
            const bell = row[i];
            const isLive = state.liveBells.includes(bell);

            if (!faded && i === highlightPos) {
              sctx.fillStyle = (cd === 'Ready') ? 'rgba(232,238,255,0.86)' : '#f9c74f';
              roundRect(sctx, i * cellW + 4, 6, cellW - 8, rowBlockH - 12, 10);
              sctx.fill();
              sctx.fillStyle = '#10162c';
            } else sctx.fillStyle = isLive ? '#e8eeff' : '#9aa2bb';

            sctx.fillText(String(bell), x, y);
          }
          sctx.restore();
        }

        drawRow(currentRow, padY, pos, false);
        drawRow(nextRow, padY + rowBlockH + gapY, -1, true);
        return;
      }

      // === Swaps View ===
      const rows = state.rows;
      const padX = 14, padY = 12;
      const gapY = 8;
      const diagramH = 18;

      const show0 = !!state.spotlightShowN;
      const show1 = !!state.spotlightShowN1 && (rowIdx + 1 < rows.length);
      const show2 = !!state.spotlightShowN2 && (rowIdx + 2 < rows.length);

      const row0 = rows[rowIdx] || rows[0];
      const row1 = show1 ? rows[rowIdx + 1] : null;
      const row2 = show2 ? rows[rowIdx + 2] : null;

      const items = [];
      if (show0) items.push({ type: 'row', row: row0, highlightPos: pos, faded: false, offset: 0 });
      if (show0 && show1) items.push({ type: 'diagram', before: row0, after: row1 });
      if (show1) items.push({ type: 'row', row: row1, highlightPos: -1, faded: true, offset: 1 });
      if (show1 && show2) items.push({ type: 'diagram', before: row1, after: row2 });
      if (show2) items.push({ type: 'row', row: row2, highlightPos: -1, faded: true, offset: 2 });

      const rowCount = items.reduce((n, it) => n + (it.type === 'row' ? 1 : 0), 0);
      if (!rowCount) return;

      // If row N is hidden, avoid a permanently "faded" first row.
      if (!show0) {
        for (let i = 0; i < items.length; i++) {
          if (items[i].type === 'row') { items[i].faded = false; break; }
        }
      }

      const diagramCount = items.length - rowCount;
      const availH = H - padY * 2;
      const gapsH = Math.max(0, (items.length - 1) * gapY);
      let rowBlockH = (availH - diagramCount * diagramH - gapsH) / rowCount;
      if (!isFinite(rowBlockH) || rowBlockH <= 0) rowBlockH = Math.max(34, (availH - diagramCount * diagramH) / rowCount);

      const cellW = (W - padX * 2) / stage;
      const liveSet = new Set(state.liveBells);

      function drawRowBlock(row, yTop, highlightPos, faded) {
        sctx.save();
        sctx.translate(padX, yTop);
        sctx.fillStyle = faded ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.05)';
        sctx.strokeStyle = 'rgba(255,255,255,0.08)';
        roundRect(sctx, 0, 0, W - padX * 2, rowBlockH, 12);
        sctx.fill(); sctx.stroke();

        const fontSize = Math.max(16, Math.min(34, Math.floor(rowBlockH * 0.58)));
        sctx.font = fontSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
        sctx.textAlign = 'center';
        sctx.textBaseline = 'middle';

        for (let i = 0; i < stage; i++) {
          const x = i * cellW + cellW / 2;
          const y = rowBlockH / 2;
          const bell = row[i];
          const isLive = liveSet.has(bell);

          if (!faded && i === highlightPos) {
            sctx.fillStyle = (cd === 'Ready') ? 'rgba(232,238,255,0.86)' : '#f9c74f';
            roundRect(sctx, i * cellW + 4, 6, cellW - 8, rowBlockH - 12, 10);
            sctx.fill();
            sctx.fillStyle = '#10162c';
          } else sctx.fillStyle = isLive ? '#e8eeff' : '#9aa2bb';

          sctx.fillText(String(bell), x, y);
        }

        sctx.restore();
      }

      function drawSwapDiagram(before, after, yTop) {
        if (!before || !after) return;
        sctx.save();
        sctx.translate(padX, yTop);

        const y1 = 2;
        const y2 = diagramH - 2;

        for (let i = 0; i < stage; i++) {
          const bell = before[i];
          const j = after.indexOf(bell);
          if (j < 0) continue;

          const x1 = i * cellW + cellW / 2;
          const x2 = j * cellW + cellW / 2;
          const isLive = liveSet.has(bell);

          sctx.strokeStyle = isLive ? 'rgba(232,238,255,0.60)' : 'rgba(154,162,187,0.20)';
          sctx.lineWidth = isLive ? 1.5 : 1;
          sctx.beginPath();
          sctx.moveTo(x1, y1);
          sctx.lineTo(x2, y2);
          sctx.stroke();
        }
        sctx.restore();
      }

      let y = padY;
      for (let k = 0; k < items.length; k++) {
        const it = items[k];
        if (it.type === 'row') {
          drawRowBlock(it.row, y, it.highlightPos, it.faded);
          y += rowBlockH;
        } else {
          drawSwapDiagram(it.before, it.after, y);
          y += diagramH;
        }
        if (k < items.length - 1) y += gapY;
      }
    }

  // === Display (polygon; primary touch control) ===
  function computeDisplayPoints(W, H) {
    const cx = W / 2;
    const cy = H / 2;
    const r = Math.min(W, H) * 0.34;
    const pts = [];
    for (let b = 1; b <= state.stage; b++) {
      const ang = -Math.PI / 2 + (b - 1) * (2 * Math.PI / state.stage);
      pts.push({ bell: b, x: cx + Math.cos(ang) * r, y: cy + Math.sin(ang) * r });
    }
    return { cx, cy, r, pts };
  }


  function getSortedLiveBells() {
    return state.liveBells.slice().filter(b => b >= 1 && b <= state.stage).sort((a,b)=>a-b);
  }

  function computeDisplayLiveOnlyLayout(W, H, bellsSorted) {
    const padX = 14;
    const padY = 12;
    const x0 = padX, y0 = padY;
    const w0 = W - padX * 2;
    const h0 = H - padY * 2;

    const n = bellsSorted.length;

    let rows = 1, cols = Math.max(1, n);
    if (n <= 3) { rows = 1; cols = Math.max(1, n); }
    else if (n === 4) { rows = 2; cols = 2; }
    else if (n <= 6) { rows = 2; cols = 3; }
    else if (n <= 8) { rows = 2; cols = 4; }
    else {
      cols = Math.ceil(Math.sqrt(n));
      rows = Math.ceil(n / cols);
    }

    const cellW = w0 / cols;
    const cellH = h0 / rows;

    return { x0, y0, w0, h0, rows, cols, cellW, cellH, bells: bellsSorted };
  }

  function drawDisplayLiveOnly(nowMs, W, H, bellsSorted) {
    const layout = computeDisplayLiveOnlyLayout(W, H, bellsSorted);
    const n = bellsSorted.length;
    const totalCells = layout.rows * layout.cols;

    let inset = Math.floor(Math.min(layout.cellW, layout.cellH) * 0.08);
    inset = Math.max(6, Math.min(14, inset));
    inset = Math.max(4, Math.min(inset, Math.floor(layout.cellW / 2 - 10), Math.floor(layout.cellH / 2 - 10)));

    for (let idx = 0; idx < totalCells; idx++) {
      const row = Math.floor(idx / layout.cols);
      const col = idx % layout.cols;
      const x = layout.x0 + col * layout.cellW;
      const y = layout.y0 + row * layout.cellH;

      const tx = x + inset;
      const ty = y + inset;
      const tw = layout.cellW - inset * 2;
      const th = layout.cellH - inset * 2;
      if (tw <= 0 || th <= 0) continue;

      const rr = Math.min(16, tw / 2, th / 2);

      dctx.save();
      dctx.fillStyle = 'rgba(255,255,255,0.04)';
      dctx.strokeStyle = 'rgba(255,255,255,0.08)';
      roundRect(dctx, tx, ty, tw, th, rr);
      dctx.fill(); dctx.stroke();
      dctx.restore();

      if (idx >= n) continue;

      const bell = bellsSorted[idx];
      const cx = x + layout.cellW / 2;
      const cy = y + layout.cellH / 2;

      const t = state.lastRingAtMs[bell] || -1e9;
      const age = nowMs - t;

      let glow = 0;
      if (age >= 0 && age <= 260) glow = 1 - (age / 260);
      if (age < 0 && age >= -60) glow = 0.25;

      const minDim = Math.max(10, Math.min(tw, th));
      let ringRadius = minDim * (n === 1 ? 0.42 : 0.36);
      ringRadius = Math.max(18, Math.min(ringRadius, minDim / 2 - 10));
      const fontSize = Math.max(16, Math.min(96, Math.floor(ringRadius * 0.9)));
      const lineW = Math.max(2, Math.min(6, ringRadius * 0.06));
      const glowExtra = Math.max(6, Math.min(18, ringRadius * 0.18));

      dctx.save();
      dctx.fillStyle = 'rgba(255,255,255,0.05)';
      dctx.strokeStyle = 'rgba(249,199,79,0.50)';
      dctx.lineWidth = lineW;
      dctx.beginPath();
      dctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
      dctx.fill();
      dctx.stroke();

      if (glow > 0) {
        dctx.fillStyle = `rgba(249,199,79,${0.18 + glow * 0.30})`;
        dctx.beginPath();
        dctx.arc(cx, cy, ringRadius + glowExtra, 0, Math.PI * 2);
        dctx.fill();
      }

      dctx.font = fontSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
      dctx.textAlign = 'center';
      dctx.textBaseline = 'middle';
      dctx.fillStyle = glow > 0.2 ? '#10162c' : '#e8eeff';
      dctx.fillText(String(bell), cx, cy);
      dctx.restore();
    }
  }


  function drawDisplay(nowMs) {
    const { W, H } = fitCanvas(displayCanvas, dctx);
    dctx.clearRect(0, 0, W, H);

    dctx.save();
    dctx.fillStyle = 'rgba(255,255,255,0.03)';
    dctx.strokeStyle = 'rgba(255,255,255,0.08)';
    roundRect(dctx, 14, 12, W - 28, H - 24, 16);
    dctx.fill(); dctx.stroke();
    dctx.restore();

    if (state.displayLiveBellsOnly) {
      const liveSorted = getSortedLiveBells();
      if (liveSorted.length) {
        drawDisplayLiveOnly(nowMs, W, H, liveSorted);
        return;
      }
    }

    const geom = computeDisplayPoints(W, H);

    const ringRadius = Math.max(18, Math.min(34, Math.floor(Math.min(W, H) * 0.06)));
    const fontSize = Math.max(16, Math.min(26, Math.floor(ringRadius * 0.9)));

    dctx.save();
    dctx.strokeStyle = 'rgba(255,255,255,0.06)';
    dctx.setLineDash([4, 6]);
    dctx.beginPath();
    geom.pts.forEach((p, i) => { if (i === 0) dctx.moveTo(p.x, p.y); else dctx.lineTo(p.x, p.y); });
    dctx.closePath();
    dctx.stroke();
    dctx.setLineDash([]);
    dctx.restore();

    for (const p of geom.pts) {
      const bell = p.bell;
      const isLive = state.liveBells.includes(bell);
      const t = state.lastRingAtMs[bell] || -1e9;
      const age = nowMs - t;

      let glow = 0;
      if (age >= 0 && age <= 260) glow = 1 - (age / 260);
      if (age < 0 && age >= -60) glow = 0.25;

      dctx.save();
      dctx.fillStyle = 'rgba(255,255,255,0.05)';
      dctx.strokeStyle = isLive ? 'rgba(249,199,79,0.50)' : 'rgba(255,255,255,0.12)';
      dctx.lineWidth = 2;
      dctx.beginPath();
      dctx.arc(p.x, p.y, ringRadius, 0, Math.PI * 2);
      dctx.fill();
      dctx.stroke();

      if (glow > 0) {
        dctx.fillStyle = `rgba(249,199,79,${0.18 + glow * 0.30})`;
        dctx.beginPath();
        dctx.arc(p.x, p.y, ringRadius + 6, 0, Math.PI * 2);
        dctx.fill();
      }

      dctx.font = fontSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
      dctx.textAlign = 'center';
      dctx.textBaseline = 'middle';
      dctx.fillStyle = glow > 0.2 ? '#10162c' : (isLive ? '#e8eeff' : '#9aa2bb');
      dctx.fillText(String(bell), p.x, p.y);
      dctx.restore();
    }
  }

  function displayHitTest(clientX, clientY) {
    const rect = displayCanvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    if (x < 0 || y < 0 || x > rect.width || y > rect.height) return null;

    const liveSorted = getSortedLiveBells();
    if (state.displayLiveBellsOnly && liveSorted.length) {
      const layout = computeDisplayLiveOnlyLayout(rect.width, rect.height, liveSorted);
      if (x < layout.x0 || y < layout.y0 || x > layout.x0 + layout.w0 || y > layout.y0 + layout.h0) return null;

      const col = Math.floor((x - layout.x0) / layout.cellW);
      const row = Math.floor((y - layout.y0) / layout.cellH);
      if (col < 0 || row < 0 || col >= layout.cols || row >= layout.rows) return null;

      const idx = row * layout.cols + col;
      return (idx >= 0 && idx < liveSorted.length) ? liveSorted[idx] : null;
    }

    const geom = computeDisplayPoints(rect.width, rect.height);
    const ringRadius = Math.max(18, Math.min(34, Math.floor(Math.min(rect.width, rect.height) * 0.06)));

    let best = null;
    let bestD2 = Infinity;
    for (const p of geom.pts) {
      const dx = x - p.x;
      const dy = y - p.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2) { bestD2 = d2; best = p.bell; }
    }
    if (best == null) return null;
    return bestD2 <= (ringRadius + 10) * (ringRadius + 10) ? best : null;
  }

  // === Notation ===
  const PATH_STYLES = [[ ], [8,4], [2,6], [10,4,2,4], [4,4], [1,3], [12,5,3,5]];

  function drawNotation() {
    const { W, H } = fitCanvas(notationCanvas, nctx);
    nctx.clearRect(0, 0, W, H);
    if (!state.rows.length) return;

    const stage = state.stage;
    const rows = state.rows;
    const totalBeats = rows.length * stage;
    const strikeIdx = clamp(state.execBeatIndex - 1, 0, Math.max(0, totalBeats - 1));
    const activeRowIdx = Math.floor(strikeIdx / stage);

    const pad = 14, gap = 14;
    const pageW = (W - pad * 2 - gap) / 2;
    const pageH = H - pad * 2;
    const titleH = 18;

    const lineH = 24;
    const fontSize = 20;
    const usable = pageH - titleH - 18;
    const pageSize = clamp(Math.floor(usable / lineH), 10, 24);

    const pageStart = Math.floor(activeRowIdx / pageSize) * pageSize;
    const pageAStart = pageStart;
    const pageBStart = pageStart + pageSize;

    const bellsForPath = state.pathBells.slice().sort((a,b)=>a-b);
    const liveSet = new Set(state.liveBells);

    function drawPage(pageStartRow, x0, y0, label, isCurrent) {
      const w0 = pageW, h0 = pageH;
      nctx.save();
      nctx.fillStyle = 'rgba(255,255,255,0.03)';
      nctx.strokeStyle = 'rgba(255,255,255,0.08)';
      roundRect(nctx, x0, y0, w0, h0, 16);
      nctx.fill(); nctx.stroke();

      nctx.font = '11px system-ui, -apple-system, "Segoe UI", sans-serif';
      nctx.fillStyle = isCurrent ? 'rgba(249,199,79,0.92)' : 'rgba(200,210,235,0.75)';
      nctx.textAlign = 'left';
      nctx.textBaseline = 'top';
      nctx.fillText(label, x0 + 10, y0 + 8);

      const contentTop = y0 + titleH + 12;
      const contentBottom = y0 + h0 - 12;
      const contentH = contentBottom - contentTop;

      const maxColW = 60;
      const baseColW = w0 / stage;
      const colW = Math.min(baseColW, maxColW);
      const gridW = colW * stage;
      const left = x0 + (w0 - gridW) / 2;
      const rowsToShow = pageSize;

      nctx.strokeStyle = 'rgba(255,255,255,0.06)';
      nctx.setLineDash([4,5]);
      for (let j = 0; j <= stage; j++) {
        const x = left + j * colW;
        nctx.beginPath(); nctx.moveTo(x, contentTop); nctx.lineTo(x, contentBottom); nctx.stroke();
      }
      nctx.setLineDash([]);

      // clip
      nctx.save();
      nctx.beginPath();
      nctx.rect(x0 + 2, contentTop, w0 - 4, contentH);
      nctx.clip();


      // swaps overlay (optional)
      if (state.notationSwapsOverlay) {
        nctx.save();

        // non-live swaps (very light)
        nctx.lineWidth = 1;
        nctx.strokeStyle = 'rgba(255,255,255,0.06)';
        nctx.beginPath();
        for (let i = 0; i < rowsToShow - 1; i++) {
          const beforeIdx = pageStartRow + i;
          const afterIdx = beforeIdx + 1;
          if (afterIdx >= rows.length) break;
          const before = rows[beforeIdx];
          const after = rows[afterIdx];
          const y1 = contentTop + i * lineH + lineH / 2;
          const y2 = contentTop + (i + 1) * lineH + lineH / 2;

          for (let p = 0; p < stage; p++) {
            const bell = before[p];
            if (liveSet.has(bell)) continue;
            const j = after.indexOf(bell);
            if (j < 0) continue;
            const x1 = left + p * colW + colW / 2;
            const x2 = left + j * colW + colW / 2;
            nctx.moveTo(x1, y1);
            nctx.lineTo(x2, y2);
          }
        }
        nctx.stroke();

        // live swaps (slightly stronger tint)
        nctx.lineWidth = 1.25;
        nctx.strokeStyle = 'rgba(249,199,79,0.16)';
        nctx.beginPath();
        for (let i = 0; i < rowsToShow - 1; i++) {
          const beforeIdx = pageStartRow + i;
          const afterIdx = beforeIdx + 1;
          if (afterIdx >= rows.length) break;
          const before = rows[beforeIdx];
          const after = rows[afterIdx];
          const y1 = contentTop + i * lineH + lineH / 2;
          const y2 = contentTop + (i + 1) * lineH + lineH / 2;

          for (let p = 0; p < stage; p++) {
            const bell = before[p];
            if (!liveSet.has(bell)) continue;
            const j = after.indexOf(bell);
            if (j < 0) continue;
            const x1 = left + p * colW + colW / 2;
            const x2 = left + j * colW + colW / 2;
            nctx.moveTo(x1, y1);
            nctx.lineTo(x2, y2);
          }
        }
        nctx.stroke();

        nctx.restore();
      }

      // paths terminate per page
      bellsForPath.forEach((bell, bi) => {
        nctx.strokeStyle = '#f9c74f';
        nctx.lineWidth = 2;
        nctx.setLineDash(PATH_STYLES[bi % PATH_STYLES.length]);
        let prev = null;
        for (let i = 0; i < rowsToShow; i++) {
          const rowIdx = pageStartRow + i;
          if (rowIdx >= rows.length) break;
          const row = rows[rowIdx];
          const pos = row.indexOf(bell);
          if (pos < 0) continue;
          const x = left + pos * colW + colW / 2;
          const y = contentTop + i * lineH + lineH / 2;
          if (prev) { nctx.beginPath(); nctx.moveTo(prev.x, prev.y); nctx.lineTo(x, y); nctx.stroke(); }
          prev = { x, y };
        }
        nctx.setLineDash([]);
      });

      // digits
      nctx.font = fontSize + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace';
      nctx.textAlign = 'center';
      nctx.textBaseline = 'middle';

      for (let i = 0; i < rowsToShow; i++) {
        const rowIdx = pageStartRow + i;
        if (rowIdx >= rows.length) break;
        const row = rows[rowIdx];
        const y = contentTop + i * lineH + lineH / 2;
        const isActive = isCurrent && (rowIdx === activeRowIdx);

        if (isActive) {
          nctx.fillStyle = 'rgba(249,199,79,0.14)';
          roundRect(nctx, x0 + 8, y - lineH / 2 + 2, w0 - 16, lineH - 4, 10);
          nctx.fill();
        }

        for (let p = 0; p < stage; p++) {
          const bell = row[p];
          const isLive = state.liveBells.includes(bell);
          const x = left + p * colW + colW / 2;
          nctx.fillStyle = isActive ? (isLive ? '#ffffff' : '#c6cbe0') : (isLive ? '#dde8ff' : '#9aa2bb');
          nctx.fillText(String(bell), x, y);
        }
      }

      nctx.restore();
      nctx.restore();
    }

    drawPage(pageAStart, pad, pad, 'CURRENT PAGE', true);
    drawPage(pageBStart, pad + pageW + gap, pad, 'NEXT PAGE', false);
  }

  // === Stats render (Mean Δ only + scale/octave) ===
  function fmtMs(ms, signed) {
    if (ms == null || isNaN(ms)) return '&ndash;';
    const v = Math.round(ms);
    if (signed) {
      if (v === 0) return '0';
      const sign = v > 0 ? '+' : '−';
      return sign + Math.abs(v);
    }
    return String(v);
  }

  function getPRCombo() {
    const t = analytics.totals || analytics.refreshTotals();
    return Number((t && t.pr_combo_global) || 0);
  }

  function renderStats(nowMs) {
    if (!viewStats.checked) return;
    const live = state.liveBells.slice().sort((a,b)=>a-b);
    if (!live.length) { statsDiv.textContent = 'No live bells selected.'; return; }

    let totalHits = 0, totalMisses = 0, sumAbs = 0, sumSigned = 0, scoreTotal = 0;
    live.forEach(b => {
      const s = state.statsByBell[b];
      totalHits += s.hits;
      totalMisses += s.misses;
      sumAbs += s.sumAbsDelta;
      sumSigned += s.sumSignedDelta;
      scoreTotal += s.score;
    });

    const totalTargets = totalHits + totalMisses;
    const rowsCompleted = Math.min(Math.floor(state.execBeatIndex / state.stage), state.rows.length);
    const totalRows = state.rows.length;

    const accOverall = totalTargets > 0 ? (totalHits / totalTargets) * 100 : null;
    const meanSignedOverall = totalHits > 0 ? Math.round(sumSigned / totalHits) : null;
    const elapsed = getElapsedSeconds(nowMs);
    let html = '';
    html += '<div class="summary">';
    html += 'Rows: ' + rowsCompleted + ' / ' + totalRows + ' &nbsp; ';
    html += 'Acc%: ' + (accOverall == null ? '&ndash;' : accOverall.toFixed(0)) + ' &nbsp; ';
    html += 'Combo: ' + state.comboCurrentGlobal + ' (best ' + state.comboBestGlobal + ') &nbsp; ';
    html += 'Mean Δ: ' + (meanSignedOverall == null ? '&ndash;' : fmtMs(meanSignedOverall, true) + ' ms') + ' &nbsp; ';
    html += 'Score: ' + Math.round(scoreTotal) + ' &nbsp; ';
    html += 'Time: ' + elapsed.toFixed(1) + ' s';
    html += '</div>';

    html += '<table><thead><tr>';
    html += '<th>Bell</th><th>Targets</th><th>Hits</th><th>Misses</th><th>Acc%</th><th>Cur combo</th><th>Best combo</th><th>Mean Δ</th><th>Score</th>';
    html += '</tr></thead><tbody>';

    live.forEach(bell => {
      const s = state.statsByBell[bell];
      const targets = s.hits + s.misses;
      const acc = targets > 0 ? (s.hits / targets) * 100 : null;
      const meanSigned = s.hits > 0 ? Math.round(s.sumSignedDelta / s.hits) : null;

      html += '<tr>';
      html += '<td>' + bell + '</td>';
      html += '<td>' + targets + '</td>';
      html += '<td>' + s.hits + '</td>';
      html += '<td>' + s.misses + '</td>';
      html += '<td>' + (acc == null ? '&ndash;' : acc.toFixed(0)) + '</td>';
      html += '<td>' + s.comboCurrent + '</td>';
      html += '<td>' + s.comboBest + '</td>';
      html += '<td>' + fmtMs(meanSigned, true) + '</td>';
      html += '<td>' + Math.round(s.score) + '</td>';
      html += '</tr>';
    });

    html += '</tbody></table>';

    html += '<div class="stats-info">';
    html += 'Scoring: each row is divided into ' + state.stage + ' bell windows. ';
    html += 'For each live bell and row, you get one scoring chance. ';
    html += 'Within a bell window, hits in the middle third earn 10 points, ';
    html += 'hits in either outer third earn 9 points. ';
    html += 'If your first ring for that bell in the row is outside its window, it scores 0. Extra rings still sound but only the first ring for a bell in a row counts for scoring. ';
    html += 'Δ is the signed timing error relative to the beat (negative = early, positive = late).';
    html += '</div>';

    statsDiv.innerHTML = html;
  }

  // === Engine start/stop + analytics ===
  function startPressed() {
    if (!state.rows.length) { alert('No rows loaded.'); return; }

    state.keybindCaptureBell = null;
    rebuildKeybindPanel();

    const playId = rid('p_');
    state.currentPlay = { playId, began: false };

    const tempoBpm = clamp(parseInt(bpmInput.value, 10) || 80, 30, 240);
    state.bpm = tempoBpm;
    bpmInput.value = String(state.bpm);
    const beatMs = 60000 / state.bpm;

    const pathMode = getPathMode();
    const pathBellsStr = (pathMode === 'custom')
      ? state.pathBells.slice().sort((a,b)=>a-b).join(',')
      : (pathMode === 'all')
        ? Array.from({length: state.stage}, (_,i)=>i+1).join(',')
        : '';

    analytics.track('play_start', {
      play_id: playId,
      session_id: analytics.sessionId,
      method: state.method,
      method_label: methodLabel(),
      stage: state.stage,
      live_count: state.liveCount,
      live_bells: state.liveBells.slice().sort((a,b)=>a-b).join(','),
      tempo_bpm: tempoBpm,
      hit_window_ms: Math.round(beatMs / 2),
      view_display: viewDisplay.checked ? 1 : 0,
      view_spotlight: viewSpotlight.checked ? 1 : 0,
      view_notation: viewNotation.checked ? 1 : 0,
      view_stats: viewStats.checked ? 1 : 0,
      path_mode: pathMode,
      path_bells: pathMode === 'none' ? '' : pathBellsStr,
      treble_tone: currentTrebleToneLabel(),
      octave: currentOctaveLabel()
    });

    ensureAudio();
    if (state.micEnabled && !state.micActive && getMicControlledBells().length) startMicCapture();

    const now = perfNow();

    state.phase = 'countdown';
    state.elapsedMs = 0;
    state.runStartPerfMs = 0;
    state.schedBeatIndex = 0;
    state.execBeatIndex = 0;
    state.targets.length = 0;
    resetStats();

    state.countFirstBeatMs = now + beatMs;
    state.countExec = 0;
    state.countSched = 0;
    state.countdownBeats = state.stage; // rounds: 1..stage
    state.methodStartMs = state.countFirstBeatMs + state.countdownBeats * beatMs;

    // Build all scoring targets upfront for row-based scoring.
    buildAllTargets(beatMs);

    startBtn.disabled = true;
    stopBtn.disabled = false;
  }

  function buildPlayEndPayload(nowMs, endReason) {
    updateMisses(nowMs);
    finalizePendingAsMisses(nowMs);

    const live = state.liveBells.slice().sort((a,b)=>a-b);
    let totalHits = 0, totalMisses = 0, sumAbs = 0, sumSigned = 0, scoreTotal = 0;

    for (const b of live) {
      const s = state.statsByBell[b];
      totalHits += s.hits;
      totalMisses += s.misses;
      sumAbs += s.sumAbsDelta;
      sumSigned += s.sumSignedDelta;
      scoreTotal += s.score;
    }
    const totalTargets = totalHits + totalMisses;
    const accuracyPct = totalTargets > 0 ? (totalHits / totalTargets) * 100 : 0;

    const meanAbs = totalHits > 0 ? Math.round(sumAbs / totalHits) : 0;
    const meanSigned = totalHits > 0 ? Math.round(sumSigned / totalHits) : 0;

    const totalBeats = state.rows.length * state.stage;
    const beatsExecuted = clamp(state.execBeatIndex, 0, totalBeats);
    const rowsCompleted = Math.min(Math.floor(beatsExecuted / state.stage), state.rows.length);

    const durationMs = Math.max(0, Math.round(state.elapsedMs));

    const parts = [];
    for (const b of live) {
      const s = state.statsByBell[b];
      const targets = s.hits + s.misses;
      const ma = s.hits > 0 ? Math.round(s.sumAbsDelta / s.hits) : 0;
      const ms = s.hits > 0 ? Math.round(s.sumSignedDelta / s.hits) : 0;
      const msStr = (ms > 0 ? '+' + ms : (ms < 0 ? '' + ms : '0'));
      parts.push('b' + b +
        ':h' + s.hits +
        'm' + s.misses +
        't' + targets +
        's' + Math.round(s.score) +
        'ma' + ma +
        'ms' + msStr +
        'cb' + s.comboBest
      );
    }

    return {
      play_id: state.currentPlay ? state.currentPlay.playId : '',
      session_id: analytics.sessionId,
      end_reason: endReason,
      duration_ms: durationMs,
      rows_completed: rowsCompleted,
      total_targets: totalTargets,
      total_hits: totalHits,
      total_misses: totalMisses,
      accuracy_pct: Math.round(accuracyPct * 10) / 10,
      mean_abs_delta_ms: meanAbs,
      mean_signed_delta_ms: meanSigned,
      score_total: Math.round(scoreTotal),
      combo_best_global: state.comboBestGlobal,
      bell_stats: parts.join('|'),
      treble_tone: currentTrebleToneLabel(),
      octave: currentOctaveLabel()
    };
  }

  function updateVisitorTotals(playEndPayload) {
    const t = analytics.totals;
    t.plays_total += 1;
    t.seconds_total += Math.round((playEndPayload.duration_ms || 0) / 1000);
    t.targets_total += Number(playEndPayload.total_targets || 0);
    t.hits_total += Number(playEndPayload.total_hits || 0);
    t.misses_total += Number(playEndPayload.total_misses || 0);
    t.score_total += Number(playEndPayload.score_total || 0);

    const combo = Number(playEndPayload.combo_best_global || 0);
    if (combo > t.pr_combo_global) t.pr_combo_global = combo;

    analytics.saveTotals();
    analytics.setUserProps({
      plays_total: t.plays_total,
      seconds_total: t.seconds_total,
      targets_total: t.targets_total,
      hits_total: t.hits_total,
      misses_total: t.misses_total,
      score_total: t.score_total,
      pr_combo_global: t.pr_combo_global
    });
  }

  function stopPressed(endReason) {
    const now = perfNow();
    if (state.phase === 'running') state.elapsedMs += (now - state.runStartPerfMs);

    const hadPlay = !!state.currentPlay;

    state.phase = 'idle';
    startBtn.disabled = false;
    stopBtn.disabled = true;

    if (hadPlay) {
      const payload = buildPlayEndPayload(now, endReason);
      analytics.track('play_end', payload);
      updateVisitorTotals(payload);
      state.currentPlay = null;
    }

    closeAudio();
  }

  function scheduleCountdown(nowMs) {
    if (state.phase !== 'countdown') return;
    const beatMs = 60000 / state.bpm;
    const total = state.countdownBeats || state.stage;

    // Rounds: ring 1..stage on each beat.
    while (state.countSched < total) {
      const tMs = state.countFirstBeatMs + state.countSched * beatMs;
      if (tMs <= nowMs + LOOKAHEAD_MS) {
        const bell = (state.countSched % state.stage) + 1; // 1..stage
        playBellAt(bell, tMs);
        state.countSched += 1;
      } else break;
    }

    while (state.countExec < total) {
      const tMs = state.countFirstBeatMs + state.countExec * beatMs;
      if (nowMs >= tMs) state.countExec += 1; else break;
    }

    if (state.countExec >= total && nowMs >= state.methodStartMs) {
      state.phase = 'running';
      state.runStartPerfMs = state.methodStartMs;

      if (state.currentPlay && !state.currentPlay.began) {
        state.currentPlay.began = true;
        analytics.track('play_begin', {
          play_id: state.currentPlay.playId,
          session_id: analytics.sessionId,
          tempo_bpm: state.bpm,
          treble_tone: currentTrebleToneLabel(),
          octave: currentOctaveLabel()
        });
      }
    }
  }

  function scheduleMethod(nowMs) {
    if (state.phase !== 'running') return;
    const beatMs = 60000 / state.bpm;
    const totalBeats = state.rows.length * state.stage;
    const liveSet = new Set(state.liveBells);

    while (state.schedBeatIndex < totalBeats) {
      const tMs = state.methodStartMs + state.schedBeatIndex * beatMs;
      if (tMs <= nowMs + LOOKAHEAD_MS) {
        const bell = getBellForStrikeIndex(state.schedBeatIndex);
        if (!liveSet.has(bell)) playBellAt(bell, tMs);
        state.schedBeatIndex += 1;
      } else break;
    }

    while (state.execBeatIndex < totalBeats) {
      const tMs = state.methodStartMs + state.execBeatIndex * beatMs;
      if (nowMs >= tMs) {
        const bell = getBellForStrikeIndex(state.execBeatIndex);
        markRung(bell, tMs);
        state.execBeatIndex += 1;
      } else break;
    }

    if (state.execBeatIndex >= totalBeats) stopPressed('completed');
  }

  function loop() {
    const nowMs = perfNow();
    syncViewLayout();
    scheduleCountdown(nowMs);
    scheduleMethod(nowMs);
    updateMicAnalysis(nowMs);
    if (state.phase === 'running') updateMisses(nowMs);
    renderCountdownOverlay(nowMs);

    if (viewDisplay.checked) drawDisplay(nowMs);
    if (viewSpotlight.checked) drawSpotlight(nowMs);
    if (viewNotation.checked) drawNotation();
    if (viewStats.checked) renderStats(nowMs);

    window.requestAnimationFrame(loop);
  }

  // === Inputs ===
  document.addEventListener('keydown', (e) => {
    if (e.altKey || e.ctrlKey || e.metaKey) return;

    const t = e.target;
    if (t && (t.tagName === 'INPUT' || t.tagName === 'SELECT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;

    const k = normalizeBindKey(e.key);

    // Capture mode: bind the next key pressed to the chosen bell.
    if (state.keybindCaptureBell != null) {
      e.preventDefault();
      if (k === 'Escape') {
        state.keybindCaptureBell = null;
        rebuildKeybindPanel();
        return;
      }
      if (!isAllowedBindKey(k)) return;

      for (const b of state.liveBells) {
        if (b === state.keybindCaptureBell) continue;
        if (state.keyBindings[b] === k) {
          alert('That key is already bound to bell ' + b + '. Choose a different key.');
          return;
        }
      }

      state.keyBindings[state.keybindCaptureBell] = k;
      saveKeyBindings();
      state.keybindCaptureBell = null;
      rebuildKeybindPanel();
      return;
    }

    // Default extra keys: if exactly one live bell is selected, Space and Enter also ring it.
    if (state.liveBells.length === 1 && (k === 'Space' || k === 'Enter')) {
      e.preventDefault();
      ringBell(state.liveBells[0]);
      return;
    }

    // Keybinding match for live bells (ignore conflicts).
    let found = null;
    for (const b of state.liveBells) {
      if (state.keyBindings[b] === k) {
        if (found != null) { found = null; break; }
        found = b;
      }
    }
    if (found != null) {
      if (k === 'Space') e.preventDefault();
      ringBell(found);
      return;
    }
  });

  // Spotlight is intentionally NOT clickable in v10.
  displayCanvas.addEventListener('pointerdown', (e) => {
    const bell = displayHitTest(e.clientX, e.clientY);
    if (bell != null) { e.preventDefault(); ringBell(bell); }
  });


  // Spotlight top-row tap: ring the tapped bell (non-keyboard alternative control).
  spotlightCanvas.addEventListener('pointerdown', (e) => {
    const rect = spotlightCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

    const stage = state.stage;

    // Default Spotlight tap (unchanged): only the top row is tappable.
    if (!state.spotlightSwapsView) {
      // Mirror drawSpotlight's layout math (CSS pixels).
      const padX = 14, padY = 12, gapY = 10;
      const rowBlockH = (rect.height - padY * 2 - gapY) / 2;
      const topRowY = padY;

      // Only accept taps in the top row body (not the title area).
      if (y < topRowY || y > topRowY + rowBlockH) return;
      if (x < padX || x > rect.width - padX) return;

      const cellW = (rect.width - padX * 2) / stage;
      const idx = Math.max(0, Math.min(stage - 1, Math.floor((x - padX) / cellW)));

      if (!state.rows.length) return;

      const totalBeats = state.rows.length * stage;
      const strikeIdx = clamp(state.execBeatIndex - 1, 0, Math.max(0, totalBeats - 1));
      const rowIdx = Math.floor(strikeIdx / stage);
      const currentRow = state.rows[rowIdx] || state.rows[0];
      const bell = currentRow[idx];
      if (bell != null) {
        e.preventDefault();
        ringBell(bell);
      }
      return;
    }

    // Swaps View: keep taps aligned with the current row (N) to avoid misleading input.
    if (!state.spotlightShowN) return;
    if (!state.rows.length) return;

    const padX = 14, padY = 12;
    const gapY = 8;
    const diagramH = 18;

    const totalBeats = state.rows.length * stage;
    const strikeIdx = clamp(state.execBeatIndex - 1, 0, Math.max(0, totalBeats - 1));
    const rowIdx = Math.floor(strikeIdx / stage);
    const currentRow = state.rows[rowIdx] || state.rows[0];

    const show1 = !!state.spotlightShowN1 && (rowIdx + 1 < state.rows.length);
    const show2 = !!state.spotlightShowN2 && (rowIdx + 2 < state.rows.length);

    const rowCount = 1 + (show1 ? 1 : 0) + (show2 ? 1 : 0);
    const diagramCount = (show1 ? 1 : 0) + ((show1 && show2) ? 1 : 0);
    const itemsLen = rowCount + diagramCount;

    const availH = rect.height - padY * 2;
    const gapsH = Math.max(0, (itemsLen - 1) * gapY);
    let rowBlockH = (availH - diagramCount * diagramH - gapsH) / rowCount;
    if (!isFinite(rowBlockH) || rowBlockH <= 0) rowBlockH = Math.max(34, (availH - diagramCount * diagramH) / rowCount);

    const topRowY = padY;

    if (y < topRowY || y > topRowY + rowBlockH) return;
    if (x < padX || x > rect.width - padX) return;

    const cellW = (rect.width - padX * 2) / stage;
    const idx = Math.max(0, Math.min(stage - 1, Math.floor((x - padX) / cellW)));

    const bell = currentRow[idx];
    if (bell != null) {
      e.preventDefault();
      ringBell(bell);
    }
  });


  methodSelect.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.method = methodSelect.value;
    if (state.method !== 'custom') state.customRows = null;
    computeRows(); resetStats();
  });

  bellCountSelect.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.stage = clamp(parseInt(bellCountSelect.value,10)||6, 4, 8);
    if (state.method === 'custom') { state.method = 'plainhunt'; methodSelect.value='plainhunt'; state.customRows=null; }
    rebuildLiveCountOptions(); ensureLiveBells(); rebuildBellPicker();
    ensurePathBells(); rebuildPathPicker(); computeRows(); resetStats(); rebuildBellFrequencies();
  });

  liveCountSelect.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.liveCount = clamp(parseInt(liveCountSelect.value,10)||1, 1, state.stage);
    ensureLiveBells(); rebuildBellPicker(); resetStats();
  });

  bpmInput.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.bpm = clamp(parseInt(bpmInput.value,10)||80, 30, 240);
    bpmInput.value = String(state.bpm);
  });

  // Mic controls
  if (micToggleBtn) {
    micToggleBtn.addEventListener('click', () => {
      if (state.micEnabled) {
        if (state.micActive) setMicEnabled(false);
        else startMicCapture();
      } else {
        setMicEnabled(true);
        startMicCapture();
      }
    });
  }
  if (micCalibrateBtn) {
    micCalibrateBtn.addEventListener('click', () => {
      calibrateMicThreshold();
    });
  }
  if (micCooldown) {
    micCooldown.addEventListener('input', () => {
      state.micCooldownMs = clamp(parseFloat(micCooldown.value), 100, 400);
      safeSetLS(LS_MIC_COOLDOWN_MS, String(state.micCooldownMs));
      syncMicSlidersUI();
    });
  }

  [viewDisplay, viewSpotlight, viewNotation, viewStats, viewMic].forEach(cb => cb.addEventListener('change', syncViewLayout));

  // Display live bells only toggle (persisted)
  if (displayLiveOnly) {
    displayLiveOnly.addEventListener('change', () => {
      state.displayLiveBellsOnly = !!displayLiveOnly.checked;
      safeSetBoolLS(LS_DISPLAY_LIVE_BELLS_ONLY, state.displayLiveBellsOnly);
    });
  }

  // Spotlight swaps view + row controls
  if (spotlightSwapsView) {
    spotlightSwapsView.addEventListener('change', () => {
      state.spotlightSwapsView = spotlightSwapsView.checked;
      safeSetBoolLS(LS_SPOTLIGHT_SWAPS_VIEW, state.spotlightSwapsView);
      syncSpotlightSwapRowTogglesUI();
    });
  }

  function syncSpotlightRowPrefsFromUI() {
    if (spotlightShowN) state.spotlightShowN = !!spotlightShowN.checked;
    if (spotlightShowN1) state.spotlightShowN1 = !!spotlightShowN1.checked;
    if (spotlightShowN2) state.spotlightShowN2 = !!spotlightShowN2.checked;

    if (!state.spotlightShowN && !state.spotlightShowN1 && !state.spotlightShowN2) {
      state.spotlightShowN = true;
      if (spotlightShowN) spotlightShowN.checked = true;
    }

    safeSetBoolLS(LS_SPOTLIGHT_SHOW_N, state.spotlightShowN);
    safeSetBoolLS(LS_SPOTLIGHT_SHOW_N1, state.spotlightShowN1);
    safeSetBoolLS(LS_SPOTLIGHT_SHOW_N2, state.spotlightShowN2);
  }

  if (spotlightShowN) spotlightShowN.addEventListener('change', syncSpotlightRowPrefsFromUI);
  if (spotlightShowN1) spotlightShowN1.addEventListener('change', syncSpotlightRowPrefsFromUI);
  if (spotlightShowN2) spotlightShowN2.addEventListener('change', syncSpotlightRowPrefsFromUI);

  // Notation swaps overlay
  if (notationSwapsOverlay) {
    notationSwapsOverlay.addEventListener('change', () => {
      state.notationSwapsOverlay = notationSwapsOverlay.checked;
      safeSetBoolLS(LS_NOTATION_SWAPS_OVERLAY, state.notationSwapsOverlay);
    });
  }


  pathNoneBtn.addEventListener('click', setPathNone);
  pathAllBtn.addEventListener('click', setPathAll);

  scaleSelect.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.scaleKey = scaleSelect.value;
    rebuildBellFrequencies();
  });

  octaveSelect.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    state.octaveC = parseInt(octaveSelect.value, 10) || 3;
    rebuildBellFrequencies();
  });

  fileInput.addEventListener('change', () => {
    if (state.phase !== 'idle') return;
    const file = fileInput.files && fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const parsed = parseCustom(String(ev.target.result));
        state.method = 'custom';
        methodSelect.value = 'custom';
        state.customRows = parsed.rows.slice();
        state.stage = clamp(parsed.stage, 2, 12);

        if (state.stage <= 8) bellCountSelect.value = String(state.stage);

        rebuildLiveCountOptions();
        ensureLiveBells();
        rebuildBellPicker();
        ensurePathBells();
        rebuildPathPicker();
        computeRows();
        resetStats();
        rebuildBellFrequencies();

        alert('Custom method loaded: ' + parsed.rows.length + ' rows on ' + parsed.stage + ' bells.');
      } catch (err) {
        alert('Could not load custom method: ' + err.message);
      }
    };
    reader.readAsText(file);
  });

  startBtn.addEventListener('click', () => startPressed());
  stopBtn.addEventListener('click', () => stopPressed('stopped'));

  if (keybindResetBtn) {
    keybindResetBtn.addEventListener('click', () => {
      if (state.phase !== 'idle') return;
      state.keybindCaptureBell = null;
      resetKeyBindingsToDefaults();
      rebuildKeybindPanel();
    });
  }


  // === Boot ===
  function boot() {
    state.stage = clamp(parseInt(bellCountSelect.value,10)||6, 4, 8);
    state.liveCount = Math.min(2, state.stage);

    loadKeyBindings();

    // swaps view settings (persisted)
    state.spotlightSwapsView = safeGetBoolLS(LS_SPOTLIGHT_SWAPS_VIEW, true);
    state.spotlightShowN = safeGetBoolLS(LS_SPOTLIGHT_SHOW_N, true);
    state.spotlightShowN1 = safeGetBoolLS(LS_SPOTLIGHT_SHOW_N1, true);
    state.spotlightShowN2 = safeGetBoolLS(LS_SPOTLIGHT_SHOW_N2, true);
    state.notationSwapsOverlay = safeGetBoolLS(LS_NOTATION_SWAPS_OVERLAY, false);
    state.displayLiveBellsOnly = safeGetBoolLS(LS_DISPLAY_LIVE_BELLS_ONLY, false);

    loadMicPrefs();

    if (!state.spotlightShowN && !state.spotlightShowN1 && !state.spotlightShowN2) state.spotlightShowN = true;

    if (spotlightSwapsView) spotlightSwapsView.checked = state.spotlightSwapsView;
    if (spotlightShowN) spotlightShowN.checked = state.spotlightShowN;
    if (spotlightShowN1) spotlightShowN1.checked = state.spotlightShowN1;
    if (spotlightShowN2) spotlightShowN2.checked = state.spotlightShowN2;
    if (notationSwapsOverlay) notationSwapsOverlay.checked = state.notationSwapsOverlay;
    if (displayLiveOnly) displayLiveOnly.checked = state.displayLiveBellsOnly;


    syncSpotlightSwapRowTogglesUI();
    syncSpotlightRowPrefsFromUI();

    scaleSelect.innerHTML = '';
    for (const s of SCALE_LIBRARY) {
      const opt = document.createElement('option');
      opt.value = s.key;
      opt.textContent = s.label;
      scaleSelect.appendChild(opt);
    }
    state.scaleKey = SCALE_LIBRARY[0].key;
    scaleSelect.value = state.scaleKey;

    octaveSelect.innerHTML = '';
    for (let o = 1; o <= 6; o++) {
      const opt = document.createElement('option');
      opt.value = String(o);
      opt.textContent = 'C' + String(o);
      octaveSelect.appendChild(opt);
    }
    state.octaveC = 3;
    octaveSelect.value = String(state.octaveC);

    rebuildLiveCountOptions();
    ensureLiveBells();
    rebuildBellPicker();

    state.pathBells = [];
    rebuildPathPicker();

    computeRows();
    resetStats();
    rebuildBellFrequencies();
    syncViewLayout();

    analytics.configure();
    analytics.setUserProps({
      plays_total: analytics.totals.plays_total,
      seconds_total: analytics.totals.seconds_total,
      targets_total: analytics.totals.targets_total,
      hits_total: analytics.totals.hits_total,
      misses_total: analytics.totals.misses_total,
      score_total: analytics.totals.score_total,
      pr_combo_global: analytics.totals.pr_combo_global
    });
    analytics.track('game_start', { session_id: analytics.sessionId, site_version: SITE_VERSION });

    window.addEventListener('pagehide', stopMicCapture);
    window.addEventListener('beforeunload', stopMicCapture);

    window.requestAnimationFrame(loop);
  }

  boot();
})();
    </script>
  </body>
</html>
